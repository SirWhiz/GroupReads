{"remainingRequest":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\xampp\\htdocs\\GroupReads\\node_modules\\rxjs\\_esm5\\Notification.js","dependencies":[{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\rxjs\\_esm5\\Notification.js","mtime":1524743247552},{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1524743208736},{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1524743165754}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START ._Observable PURE_IMPORTS_END */\r\nimport { Observable } from './Observable';\r\n/**\r\n * Represents a push-based event or value that an {@link Observable} can emit.\r\n * This class is particularly useful for operators that manage notifications,\r\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\r\n * others. Besides wrapping the actual delivered value, it also annotates it\r\n * with metadata of, for instance, what type of push message it is (`next`,\r\n * `error`, or `complete`).\r\n *\r\n * @see {@link materialize}\r\n * @see {@link dematerialize}\r\n * @see {@link observeOn}\r\n *\r\n * @class Notification<T>\r\n */\r\nexport var Notification = /*@__PURE__*/ (function () {\r\n    function Notification(kind, value, error) {\r\n        this.kind = kind;\r\n        this.value = value;\r\n        this.error = error;\r\n        this.hasValue = kind === 'N';\r\n    }\r\n    /**\r\n     * Delivers to the given `observer` the value wrapped by this Notification.\r\n     * @param {Observer} observer\r\n     * @return\r\n     */\r\n    Notification.prototype.observe = function (observer) {\r\n        switch (this.kind) {\r\n            case 'N':\r\n                return observer.next && observer.next(this.value);\r\n            case 'E':\r\n                return observer.error && observer.error(this.error);\r\n            case 'C':\r\n                return observer.complete && observer.complete();\r\n        }\r\n    };\r\n    /**\r\n     * Given some {@link Observer} callbacks, deliver the value represented by the\r\n     * current Notification to the correctly corresponding callback.\r\n     * @param {function(value: T): void} next An Observer `next` callback.\r\n     * @param {function(err: any): void} [error] An Observer `error` callback.\r\n     * @param {function(): void} [complete] An Observer `complete` callback.\r\n     * @return {any}\r\n     */\r\n    Notification.prototype.do = function (next, error, complete) {\r\n        var kind = this.kind;\r\n        switch (kind) {\r\n            case 'N':\r\n                return next && next(this.value);\r\n            case 'E':\r\n                return error && error(this.error);\r\n            case 'C':\r\n                return complete && complete();\r\n        }\r\n    };\r\n    /**\r\n     * Takes an Observer or its individual callback functions, and calls `observe`\r\n     * or `do` methods accordingly.\r\n     * @param {Observer|function(value: T): void} nextOrObserver An Observer or\r\n     * the `next` callback.\r\n     * @param {function(err: any): void} [error] An Observer `error` callback.\r\n     * @param {function(): void} [complete] An Observer `complete` callback.\r\n     * @return {any}\r\n     */\r\n    Notification.prototype.accept = function (nextOrObserver, error, complete) {\r\n        if (nextOrObserver && typeof nextOrObserver.next === 'function') {\r\n            return this.observe(nextOrObserver);\r\n        }\r\n        else {\r\n            return this.do(nextOrObserver, error, complete);\r\n        }\r\n    };\r\n    /**\r\n     * Returns a simple Observable that just delivers the notification represented\r\n     * by this Notification instance.\r\n     * @return {any}\r\n     */\r\n    Notification.prototype.toObservable = function () {\r\n        var kind = this.kind;\r\n        switch (kind) {\r\n            case 'N':\r\n                return Observable.of(this.value);\r\n            case 'E':\r\n                return Observable.throw(this.error);\r\n            case 'C':\r\n                return Observable.empty();\r\n        }\r\n        throw new Error('unexpected notification kind value');\r\n    };\r\n    /**\r\n     * A shortcut to create a Notification instance of the type `next` from a\r\n     * given value.\r\n     * @param {T} value The `next` value.\r\n     * @return {Notification<T>} The \"next\" Notification representing the\r\n     * argument.\r\n     */\r\n    Notification.createNext = function (value) {\r\n        if (typeof value !== 'undefined') {\r\n            return new Notification('N', value);\r\n        }\r\n        return Notification.undefinedValueNotification;\r\n    };\r\n    /**\r\n     * A shortcut to create a Notification instance of the type `error` from a\r\n     * given error.\r\n     * @param {any} [err] The `error` error.\r\n     * @return {Notification<T>} The \"error\" Notification representing the\r\n     * argument.\r\n     */\r\n    Notification.createError = function (err) {\r\n        return new Notification('E', undefined, err);\r\n    };\r\n    /**\r\n     * A shortcut to create a Notification instance of the type `complete`.\r\n     * @return {Notification<any>} The valueless \"complete\" Notification.\r\n     */\r\n    Notification.createComplete = function () {\r\n        return Notification.completeNotification;\r\n    };\r\n    Notification.completeNotification = new Notification('C');\r\n    Notification.undefinedValueNotification = new Notification('N', undefined);\r\n    return Notification;\r\n}());\r\n//# sourceMappingURL=Notification.js.map\r\n",null]}