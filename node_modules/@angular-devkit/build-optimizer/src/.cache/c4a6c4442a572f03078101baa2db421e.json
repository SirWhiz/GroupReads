{"remainingRequest":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular\\material\\esm5\\tooltip.es5.js","dependencies":[{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular\\material\\esm5\\tooltip.es5.js","mtime":1524743173802},{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1524743208736},{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1524743165754}],"contextDependencies":[],"result":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** PURE_IMPORTS_START _angular_cdk_a11y,_angular_cdk_overlay,_angular_cdk_platform,_angular_common,_angular_core,_angular_material_core,_angular_cdk_layout,_angular_cdk_bidi,_angular_cdk_coercion,_angular_cdk_keycodes,_angular_cdk_portal,rxjs_operators_take,rxjs_observable_merge,_angular_cdk_scrolling,rxjs_Subject,_angular_animations PURE_IMPORTS_END */\nimport { A11yModule, ARIA_DESCRIBER_PROVIDER, AriaDescriber, FocusMonitor } from '@angular/cdk/a11y';\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\nimport { Platform, PlatformModule } from '@angular/cdk/platform';\nimport { CommonModule } from '@angular/common';\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component, Directive, ElementRef, Inject, InjectionToken, Input, NgModule, NgZone, Optional, ViewContainerRef, ViewEncapsulation } from '@angular/core';\nimport { MatCommonModule } from '@angular/material/core';\nimport { BreakpointObserver, Breakpoints, LayoutModule } from '@angular/cdk/layout';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ESCAPE } from '@angular/cdk/keycodes';\nimport { ComponentPortal } from '@angular/cdk/portal';\nimport { take } from 'rxjs/operators/take';\nimport { merge } from 'rxjs/observable/merge';\nimport { ScrollDispatcher } from '@angular/cdk/scrolling';\nimport { Subject } from 'rxjs/Subject';\nimport { animate, state, style, transition, trigger } from '@angular/animations';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Animations used by MatTooltip.\n */\nvar matTooltipAnimations = {\n    /** Animation that transitions a tooltip in and out. */\n    tooltipState: /*@__PURE__*/ trigger('state', [\n        /*@__PURE__*/ state('initial, void, hidden', /*@__PURE__*/ style({ transform: 'scale(0)' })),\n        /*@__PURE__*/ state('visible', /*@__PURE__*/ style({ transform: 'scale(1)' })),\n        /*@__PURE__*/ transition('* => visible', /*@__PURE__*/ animate('150ms cubic-bezier(0.0, 0.0, 0.2, 1)')),\n        /*@__PURE__*/ transition('* => hidden', /*@__PURE__*/ animate('150ms cubic-bezier(0.4, 0.0, 1, 1)')),\n    ])\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Time in ms to throttle repositioning after scroll events.\n */\nvar SCROLL_THROTTLE_MS = 20;\n/**\n * CSS class that will be attached to the overlay panel.\n */\nvar TOOLTIP_PANEL_CLASS = 'mat-tooltip-panel';\n/**\n * Creates an error to be thrown if the user supplied an invalid tooltip position.\n * @param {?} position\n * @return {?}\n */\nfunction getMatTooltipInvalidPositionError(position) {\n    return Error(\"Tooltip position \\\"\" + position + \"\\\" is invalid.\");\n}\n/**\n * Injection token that determines the scroll handling while a tooltip is visible.\n */\nvar MAT_TOOLTIP_SCROLL_STRATEGY = /*@__PURE__*/ new InjectionToken('mat-tooltip-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction MAT_TOOLTIP_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    return function () { return overlay.scrollStrategies.reposition({ scrollThrottle: SCROLL_THROTTLE_MS }); };\n}\n/**\n * \\@docs-private\n */\nvar MAT_TOOLTIP_SCROLL_STRATEGY_PROVIDER = {\n    provide: MAT_TOOLTIP_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: MAT_TOOLTIP_SCROLL_STRATEGY_PROVIDER_FACTORY\n};\n/**\n * Default `matTooltip` options that can be overridden.\n * @record\n */\n/**\n * Injection token to be used to override the default options for `matTooltip`.\n */\nvar MAT_TOOLTIP_DEFAULT_OPTIONS = /*@__PURE__*/ new InjectionToken('mat-tooltip-default-options');\n/**\n * Directive that attaches a material design tooltip to the host element. Animates the showing and\n * hiding of a tooltip provided position (defaults to below the element).\n *\n * https://material.google.com/components/tooltips.html\n */\nvar MatTooltip = /*@__PURE__*/ (function () {\n    function MatTooltip(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, _platform, _ariaDescriber, _focusMonitor, _scrollStrategy, _dir, _defaultOptions) {\n        // TODO(crisbeto): make the `_defaultOptions` a required param next time we do breaking changes.\n        // @deletion-target 6.0.0\n        var _this = this;\n        this._overlay = _overlay;\n        this._elementRef = _elementRef;\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewContainerRef = _viewContainerRef;\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        this._ariaDescriber = _ariaDescriber;\n        this._focusMonitor = _focusMonitor;\n        this._scrollStrategy = _scrollStrategy;\n        this._dir = _dir;\n        this._defaultOptions = _defaultOptions;\n        this._position = 'below';\n        this._disabled = false;\n        /**\n         * The default delay in ms before showing the tooltip after show is called\n         */\n        this.showDelay = this._defaultOptions ? this._defaultOptions.showDelay : 0;\n        /**\n         * The default delay in ms before hiding the tooltip after hide is called\n         */\n        this.hideDelay = this._defaultOptions ? this._defaultOptions.hideDelay : 0;\n        this._message = '';\n        this._manualListeners = new Map();\n        var /** @type {?} */ element = _elementRef.nativeElement;\n        // The mouse events shouldn't be bound on iOS devices, because\n        // they can prevent the first tap from firing its click event.\n        if (!_platform.IOS) {\n            this._manualListeners.set('mouseenter', function () { return _this.show(); });\n            this._manualListeners.set('mouseleave', function () { return _this.hide(); });\n            this._manualListeners\n                .forEach(function (listener, event) { return _elementRef.nativeElement.addEventListener(event, listener); });\n        }\n        else if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {\n            // When we bind a gesture event on an element (in this case `longpress`), HammerJS\n            // will add some inline styles by default, including `user-select: none`. This is\n            // problematic on iOS, because it will prevent users from typing in inputs. If\n            // we're on iOS and the tooltip is attached on an input or textarea, we clear\n            // the `user-select` to avoid these issues.\n            element.style.webkitUserSelect = element.style.userSelect = '';\n        }\n        _focusMonitor.monitor(element).subscribe(function (origin) {\n            // Note that the focus monitor runs outside the Angular zone.\n            if (!origin) {\n                _ngZone.run(function () { return _this.hide(0); });\n            }\n            else if (origin !== 'program') {\n                _ngZone.run(function () { return _this.show(); });\n            }\n        });\n    }\n    Object.defineProperty(MatTooltip.prototype, \"position\", {\n        get: /**\n         * Allows the user to define the position of the tooltip relative to the parent element\n         * @return {?}\n         */ function () { return this._position; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            if (value !== this._position) {\n                this._position = value;\n                // TODO(andrewjs): When the overlay's position can be dynamically changed, do not destroy\n                // the tooltip.\n                if (this._tooltipInstance) {\n                    this._disposeTooltip();\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatTooltip.prototype, \"disabled\", {\n        get: /**\n         * Disables the display of the tooltip.\n         * @return {?}\n         */ function () { return this._disabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._disabled = coerceBooleanProperty(value);\n            // If tooltip is disabled, hide immediately.\n            if (this._disabled) {\n                this.hide(0);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatTooltip.prototype, \"_positionDeprecated\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */ function () { return this._position; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) { this._position = value; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatTooltip.prototype, \"message\", {\n        get: /**\n         * The message to be displayed in the tooltip\n         * @return {?}\n         */ function () { return this._message; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this._message);\n            // If the message is not a string (e.g. number), convert it to a string and trim it.\n            this._message = value != null ? (\"\" + value).trim() : '';\n            if (!this._message && this._isTooltipVisible()) {\n                this.hide(0);\n            }\n            else {\n                this._updateTooltipMessage();\n                this._ariaDescriber.describe(this._elementRef.nativeElement, this.message);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatTooltip.prototype, \"tooltipClass\", {\n        get: /**\n         * Classes to be passed to the tooltip. Supports the same syntax as `ngClass`.\n         * @return {?}\n         */ function () { return this._tooltipClass; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._tooltipClass = value;\n            if (this._tooltipInstance) {\n                this._setTooltipClass(this._tooltipClass);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Dispose the tooltip when destroyed.\n     */\n    /**\n     * Dispose the tooltip when destroyed.\n     * @return {?}\n     */\n    MatTooltip.prototype.ngOnDestroy = /**\n     * Dispose the tooltip when destroyed.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this._tooltipInstance) {\n                this._disposeTooltip();\n            }\n            // Clean up the event listeners set in the constructor\n            if (!this._platform.IOS) {\n                this._manualListeners.forEach(function (listener, event) {\n                    _this._elementRef.nativeElement.removeEventListener(event, listener);\n                });\n                this._manualListeners.clear();\n            }\n            this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this.message);\n            this._focusMonitor.stopMonitoring(this._elementRef.nativeElement);\n        };\n    /** Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input */\n    /**\n     * Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input\n     * @param {?=} delay\n     * @return {?}\n     */\n    MatTooltip.prototype.show = /**\n     * Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input\n     * @param {?=} delay\n     * @return {?}\n     */\n        function (delay) {\n            if (delay === void 0) {\n                delay = this.showDelay;\n            }\n            if (this.disabled || !this.message) {\n                return;\n            }\n            if (!this._tooltipInstance) {\n                this._createTooltip();\n            }\n            this._setTooltipClass(this._tooltipClass);\n            this._updateTooltipMessage(); /** @type {?} */\n            ((this._tooltipInstance)).show(this._position, delay);\n        };\n    /** Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input */\n    /**\n     * Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input\n     * @param {?=} delay\n     * @return {?}\n     */\n    MatTooltip.prototype.hide = /**\n     * Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input\n     * @param {?=} delay\n     * @return {?}\n     */\n        function (delay) {\n            if (delay === void 0) {\n                delay = this.hideDelay;\n            }\n            if (this._tooltipInstance) {\n                this._tooltipInstance.hide(delay);\n            }\n        };\n    /** Shows/hides the tooltip */\n    /**\n     * Shows/hides the tooltip\n     * @return {?}\n     */\n    MatTooltip.prototype.toggle = /**\n     * Shows/hides the tooltip\n     * @return {?}\n     */\n        function () {\n            this._isTooltipVisible() ? this.hide() : this.show();\n        };\n    /** Returns true if the tooltip is currently visible to the user */\n    /**\n     * Returns true if the tooltip is currently visible to the user\n     * @return {?}\n     */\n    MatTooltip.prototype._isTooltipVisible = /**\n     * Returns true if the tooltip is currently visible to the user\n     * @return {?}\n     */\n        function () {\n            return !!this._tooltipInstance && this._tooltipInstance.isVisible();\n        };\n    /** Handles the keydown events on the host element. */\n    /**\n     * Handles the keydown events on the host element.\n     * @param {?} e\n     * @return {?}\n     */\n    MatTooltip.prototype._handleKeydown = /**\n     * Handles the keydown events on the host element.\n     * @param {?} e\n     * @return {?}\n     */\n        function (e) {\n            if (this._isTooltipVisible() && e.keyCode === ESCAPE) {\n                e.stopPropagation();\n                this.hide(0);\n            }\n        };\n    /** Handles the touchend events on the host element. */\n    /**\n     * Handles the touchend events on the host element.\n     * @return {?}\n     */\n    MatTooltip.prototype._handleTouchend = /**\n     * Handles the touchend events on the host element.\n     * @return {?}\n     */\n        function () {\n            this.hide(this._defaultOptions ? this._defaultOptions.touchendHideDelay : 1500);\n        };\n    /**\n     * Create the tooltip to display\n     * @return {?}\n     */\n    MatTooltip.prototype._createTooltip = /**\n     * Create the tooltip to display\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            var /** @type {?} */ overlayRef = this._createOverlay();\n            var /** @type {?} */ portal = new ComponentPortal(TooltipComponent, this._viewContainerRef);\n            this._tooltipInstance = overlayRef.attach(portal).instance;\n            // Dispose of the tooltip when the overlay is detached.\n            merge(/** @type {?} */ ((this._tooltipInstance)).afterHidden(), overlayRef.detachments()).subscribe(function () {\n                // Check first if the tooltip has already been removed through this components destroy.\n                if (_this._tooltipInstance) {\n                    _this._disposeTooltip();\n                }\n            });\n        };\n    /**\n     * Create the overlay config and position strategy\n     * @return {?}\n     */\n    MatTooltip.prototype._createOverlay = /**\n     * Create the overlay config and position strategy\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            var /** @type {?} */ origin = this._getOrigin();\n            var /** @type {?} */ overlay = this._getOverlayPosition();\n            // Create connected position strategy that listens for scroll events to reposition.\n            var /** @type {?} */ strategy = this._overlay\n                .position()\n                .connectedTo(this._elementRef, origin.main, overlay.main)\n                .withFallbackPosition(origin.fallback, overlay.fallback);\n            var /** @type {?} */ scrollableAncestors = this._scrollDispatcher\n                .getAncestorScrollContainers(this._elementRef);\n            strategy.withScrollableContainers(scrollableAncestors);\n            strategy.onPositionChange.subscribe(function (change) {\n                if (_this._tooltipInstance) {\n                    if (change.scrollableViewProperties.isOverlayClipped && _this._tooltipInstance.isVisible()) {\n                        // After position changes occur and the overlay is clipped by\n                        // a parent scrollable then close the tooltip.\n                        // After position changes occur and the overlay is clipped by\n                        // a parent scrollable then close the tooltip.\n                        _this._ngZone.run(function () { return _this.hide(0); });\n                    }\n                    else {\n                        // Otherwise recalculate the origin based on the new position.\n                        // Otherwise recalculate the origin based on the new position.\n                        _this._tooltipInstance._setTransformOrigin(change.connectionPair);\n                    }\n                }\n            });\n            var /** @type {?} */ config = new OverlayConfig({\n                direction: this._dir ? this._dir.value : 'ltr',\n                positionStrategy: strategy,\n                panelClass: TOOLTIP_PANEL_CLASS,\n                scrollStrategy: this._scrollStrategy()\n            });\n            this._overlayRef = this._overlay.create(config);\n            return this._overlayRef;\n        };\n    /**\n     * Disposes the current tooltip and the overlay it is attached to\n     * @return {?}\n     */\n    MatTooltip.prototype._disposeTooltip = /**\n     * Disposes the current tooltip and the overlay it is attached to\n     * @return {?}\n     */\n        function () {\n            if (this._overlayRef) {\n                this._overlayRef.dispose();\n                this._overlayRef = null;\n            }\n            this._tooltipInstance = null;\n        };\n    /**\n     * Returns the origin position and a fallback position based on the user's position preference.\n     * The fallback position is the inverse of the origin (e.g. `'below' -> 'above'`).\n     */\n    /**\n     * Returns the origin position and a fallback position based on the user's position preference.\n     * The fallback position is the inverse of the origin (e.g. `'below' -> 'above'`).\n     * @return {?}\n     */\n    MatTooltip.prototype._getOrigin = /**\n     * Returns the origin position and a fallback position based on the user's position preference.\n     * The fallback position is the inverse of the origin (e.g. `'below' -> 'above'`).\n     * @return {?}\n     */\n        function () {\n            var /** @type {?} */ isDirectionLtr = !this._dir || this._dir.value == 'ltr';\n            var /** @type {?} */ position;\n            if (this.position == 'above' || this.position == 'below') {\n                position = { originX: 'center', originY: this.position == 'above' ? 'top' : 'bottom' };\n            }\n            else if (this.position == 'left' ||\n                this.position == 'before' && isDirectionLtr ||\n                this.position == 'after' && !isDirectionLtr) {\n                position = { originX: 'start', originY: 'center' };\n            }\n            else if (this.position == 'right' ||\n                this.position == 'after' && isDirectionLtr ||\n                this.position == 'before' && !isDirectionLtr) {\n                position = { originX: 'end', originY: 'center' };\n            }\n            else {\n                throw getMatTooltipInvalidPositionError(this.position);\n            }\n            var _a = this._invertPosition(position.originX, position.originY), x = _a.x, y = _a.y;\n            return {\n                main: position,\n                fallback: { originX: x, originY: y }\n            };\n        };\n    /** Returns the overlay position and a fallback position based on the user's preference */\n    /**\n     * Returns the overlay position and a fallback position based on the user's preference\n     * @return {?}\n     */\n    MatTooltip.prototype._getOverlayPosition = /**\n     * Returns the overlay position and a fallback position based on the user's preference\n     * @return {?}\n     */\n        function () {\n            var /** @type {?} */ isLtr = !this._dir || this._dir.value == 'ltr';\n            var /** @type {?} */ position;\n            if (this.position == 'above') {\n                position = { overlayX: 'center', overlayY: 'bottom' };\n            }\n            else if (this.position == 'below') {\n                position = { overlayX: 'center', overlayY: 'top' };\n            }\n            else if (this.position == 'left' ||\n                this.position == 'before' && isLtr ||\n                this.position == 'after' && !isLtr) {\n                position = { overlayX: 'end', overlayY: 'center' };\n            }\n            else if (this.position == 'right' ||\n                this.position == 'after' && isLtr ||\n                this.position == 'before' && !isLtr) {\n                position = { overlayX: 'start', overlayY: 'center' };\n            }\n            else {\n                throw getMatTooltipInvalidPositionError(this.position);\n            }\n            var _a = this._invertPosition(position.overlayX, position.overlayY), x = _a.x, y = _a.y;\n            return {\n                main: position,\n                fallback: { overlayX: x, overlayY: y }\n            };\n        };\n    /**\n     * Updates the tooltip message and repositions the overlay according to the new message length\n     * @return {?}\n     */\n    MatTooltip.prototype._updateTooltipMessage = /**\n     * Updates the tooltip message and repositions the overlay according to the new message length\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            // Must wait for the message to be painted to the tooltip so that the overlay can properly\n            // calculate the correct positioning based on the size of the text.\n            if (this._tooltipInstance) {\n                this._tooltipInstance.message = this.message;\n                this._tooltipInstance._markForCheck();\n                this._ngZone.onMicrotaskEmpty.asObservable().pipe(take(1)).subscribe(function () {\n                    if (_this._tooltipInstance) {\n                        /** @type {?} */ ((_this._overlayRef)).updatePosition();\n                    }\n                });\n            }\n        };\n    /**\n     * Updates the tooltip class\n     * @param {?} tooltipClass\n     * @return {?}\n     */\n    MatTooltip.prototype._setTooltipClass = /**\n     * Updates the tooltip class\n     * @param {?} tooltipClass\n     * @return {?}\n     */\n        function (tooltipClass) {\n            if (this._tooltipInstance) {\n                this._tooltipInstance.tooltipClass = tooltipClass;\n                this._tooltipInstance._markForCheck();\n            }\n        };\n    /**\n     * Inverts an overlay position.\n     * @param {?} x\n     * @param {?} y\n     * @return {?}\n     */\n    MatTooltip.prototype._invertPosition = /**\n     * Inverts an overlay position.\n     * @param {?} x\n     * @param {?} y\n     * @return {?}\n     */\n        function (x, y) {\n            if (this.position === 'above' || this.position === 'below') {\n                if (y === 'top') {\n                    y = 'bottom';\n                }\n                else if (y === 'bottom') {\n                    y = 'top';\n                }\n            }\n            else {\n                if (x === 'end') {\n                    x = 'start';\n                }\n                else if (x === 'start') {\n                    x = 'end';\n                }\n            }\n            return { x: x, y: y };\n        };\n    return MatTooltip;\n}());\n/**\n * Internal component that wraps the tooltip's content.\n * \\@docs-private\n */\nvar TooltipComponent = /*@__PURE__*/ (function () {\n    function TooltipComponent(_changeDetectorRef, _breakpointObserver) {\n        this._changeDetectorRef = _changeDetectorRef;\n        this._breakpointObserver = _breakpointObserver;\n        /**\n         * Property watched by the animation framework to show or hide the tooltip\n         */\n        this._visibility = 'initial';\n        /**\n         * Whether interactions on the page should close the tooltip\n         */\n        this._closeOnInteraction = false;\n        /**\n         * The transform origin used in the animation for showing and hiding the tooltip\n         */\n        this._transformOrigin = 'bottom';\n        /**\n         * Subject for notifying that the tooltip has been hidden from the view\n         */\n        this._onHide = new Subject();\n        /**\n         * Stream that emits whether the user has a handset-sized display.\n         */\n        this._isHandset = this._breakpointObserver.observe(Breakpoints.Handset);\n    }\n    /**\n     * Shows the tooltip with an animation originating from the provided origin\n     * @param position Position of the tooltip.\n     * @param delay Amount of milliseconds to the delay showing the tooltip.\n     */\n    /**\n     * Shows the tooltip with an animation originating from the provided origin\n     * @param {?} position Position of the tooltip.\n     * @param {?} delay Amount of milliseconds to the delay showing the tooltip.\n     * @return {?}\n     */\n    TooltipComponent.prototype.show = /**\n     * Shows the tooltip with an animation originating from the provided origin\n     * @param {?} position Position of the tooltip.\n     * @param {?} delay Amount of milliseconds to the delay showing the tooltip.\n     * @return {?}\n     */\n        function (position, delay) {\n            var _this = this;\n            // Cancel the delayed hide if it is scheduled\n            if (this._hideTimeoutId) {\n                clearTimeout(this._hideTimeoutId);\n            }\n            // Body interactions should cancel the tooltip if there is a delay in showing.\n            this._closeOnInteraction = true;\n            this._position = position;\n            this._showTimeoutId = setTimeout(function () {\n                _this._visibility = 'visible';\n                // Mark for check so if any parent component has set the\n                // ChangeDetectionStrategy to OnPush it will be checked anyways\n                // Mark for check so if any parent component has set the\n                // ChangeDetectionStrategy to OnPush it will be checked anyways\n                _this._markForCheck();\n            }, delay);\n        };\n    /**\n     * Begins the animation to hide the tooltip after the provided delay in ms.\n     * @param delay Amount of milliseconds to delay showing the tooltip.\n     */\n    /**\n     * Begins the animation to hide the tooltip after the provided delay in ms.\n     * @param {?} delay Amount of milliseconds to delay showing the tooltip.\n     * @return {?}\n     */\n    TooltipComponent.prototype.hide = /**\n     * Begins the animation to hide the tooltip after the provided delay in ms.\n     * @param {?} delay Amount of milliseconds to delay showing the tooltip.\n     * @return {?}\n     */\n        function (delay) {\n            var _this = this;\n            // Cancel the delayed show if it is scheduled\n            if (this._showTimeoutId) {\n                clearTimeout(this._showTimeoutId);\n            }\n            this._hideTimeoutId = setTimeout(function () {\n                _this._visibility = 'hidden';\n                // Mark for check so if any parent component has set the\n                // ChangeDetectionStrategy to OnPush it will be checked anyways\n                // Mark for check so if any parent component has set the\n                // ChangeDetectionStrategy to OnPush it will be checked anyways\n                _this._markForCheck();\n            }, delay);\n        };\n    /** Returns an observable that notifies when the tooltip has been hidden from view. */\n    /**\n     * Returns an observable that notifies when the tooltip has been hidden from view.\n     * @return {?}\n     */\n    TooltipComponent.prototype.afterHidden = /**\n     * Returns an observable that notifies when the tooltip has been hidden from view.\n     * @return {?}\n     */\n        function () {\n            return this._onHide.asObservable();\n        };\n    /** Whether the tooltip is being displayed. */\n    /**\n     * Whether the tooltip is being displayed.\n     * @return {?}\n     */\n    TooltipComponent.prototype.isVisible = /**\n     * Whether the tooltip is being displayed.\n     * @return {?}\n     */\n        function () {\n            return this._visibility === 'visible';\n        };\n    /** Sets the tooltip transform origin according to the position of the tooltip overlay. */\n    /**\n     * Sets the tooltip transform origin according to the position of the tooltip overlay.\n     * @param {?} overlayPosition\n     * @return {?}\n     */\n    TooltipComponent.prototype._setTransformOrigin = /**\n     * Sets the tooltip transform origin according to the position of the tooltip overlay.\n     * @param {?} overlayPosition\n     * @return {?}\n     */\n        function (overlayPosition) {\n            var /** @type {?} */ axis = (this._position === 'above' || this._position === 'below') ? 'Y' : 'X';\n            var /** @type {?} */ position = axis == 'X' ? overlayPosition.overlayX : overlayPosition.overlayY;\n            if (position === 'top' || position === 'bottom') {\n                this._transformOrigin = position;\n            }\n            else if (position === 'start') {\n                this._transformOrigin = 'left';\n            }\n            else if (position === 'end') {\n                this._transformOrigin = 'right';\n            }\n            else {\n                throw getMatTooltipInvalidPositionError(this._position);\n            }\n        };\n    /**\n     * @return {?}\n     */\n    TooltipComponent.prototype._animationStart = /**\n     * @return {?}\n     */\n        function () {\n            this._closeOnInteraction = false;\n        };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    TooltipComponent.prototype._animationDone = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            var /** @type {?} */ toState = (event.toState);\n            if (toState === 'hidden' && !this.isVisible()) {\n                this._onHide.next();\n            }\n            if (toState === 'visible' || toState === 'hidden') {\n                this._closeOnInteraction = true;\n            }\n        };\n    /**\n     * Interactions on the HTML body should close the tooltip immediately as defined in the\n     * material design spec.\n     * https://material.google.com/components/tooltips.html#tooltips-interaction\n     */\n    /**\n     * Interactions on the HTML body should close the tooltip immediately as defined in the\n     * material design spec.\n     * https://material.google.com/components/tooltips.html#tooltips-interaction\n     * @return {?}\n     */\n    TooltipComponent.prototype._handleBodyInteraction = /**\n     * Interactions on the HTML body should close the tooltip immediately as defined in the\n     * material design spec.\n     * https://material.google.com/components/tooltips.html#tooltips-interaction\n     * @return {?}\n     */\n        function () {\n            if (this._closeOnInteraction) {\n                this.hide(0);\n            }\n        };\n    /**\n     * Marks that the tooltip needs to be checked in the next change detection run.\n     * Mainly used for rendering the initial text before positioning a tooltip, which\n     * can be problematic in components with OnPush change detection.\n     */\n    /**\n     * Marks that the tooltip needs to be checked in the next change detection run.\n     * Mainly used for rendering the initial text before positioning a tooltip, which\n     * can be problematic in components with OnPush change detection.\n     * @return {?}\n     */\n    TooltipComponent.prototype._markForCheck = /**\n     * Marks that the tooltip needs to be checked in the next change detection run.\n     * Mainly used for rendering the initial text before positioning a tooltip, which\n     * can be problematic in components with OnPush change detection.\n     * @return {?}\n     */\n        function () {\n            this._changeDetectorRef.markForCheck();\n        };\n    return TooltipComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar ɵ0 = {\n    showDelay: 0,\n    hideDelay: 0,\n    touchendHideDelay: 1500\n};\nvar MatTooltipModule = /*@__PURE__*/ (function () {\n    function MatTooltipModule() {\n    }\n    return MatTooltipModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { MatTooltipModule, SCROLL_THROTTLE_MS, TOOLTIP_PANEL_CLASS, getMatTooltipInvalidPositionError, MAT_TOOLTIP_SCROLL_STRATEGY, MAT_TOOLTIP_SCROLL_STRATEGY_PROVIDER_FACTORY, MAT_TOOLTIP_SCROLL_STRATEGY_PROVIDER, MAT_TOOLTIP_DEFAULT_OPTIONS, MatTooltip, TooltipComponent, matTooltipAnimations };\n//# sourceMappingURL=tooltip.es5.js.map\n",null]}