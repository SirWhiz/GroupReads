{"remainingRequest":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\xampp\\htdocs\\GroupReads\\node_modules\\rxjs\\_esm5\\observable\\ArrayObservable.js","dependencies":[{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\rxjs\\_esm5\\observable\\ArrayObservable.js","mtime":1524743247950},{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1524743208736},{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1524743165754}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { Observable } from '../Observable';\r\nimport { ScalarObservable } from './ScalarObservable';\r\nimport { EmptyObservable } from './EmptyObservable';\r\nimport { isScheduler } from '../util/isScheduler';\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @extends {Ignored}\r\n * @hide true\r\n */\r\nexport var ArrayObservable = /*@__PURE__*/ (function (_super) {\r\n    __extends(ArrayObservable, _super);\r\n    function ArrayObservable(array, scheduler) {\r\n        _super.call(this);\r\n        this.array = array;\r\n        this.scheduler = scheduler;\r\n        if (!scheduler && array.length === 1) {\r\n            this._isScalar = true;\r\n            this.value = array[0];\r\n        }\r\n    }\r\n    ArrayObservable.create = function (array, scheduler) {\r\n        return new ArrayObservable(array, scheduler);\r\n    };\r\n    /**\r\n     * Creates an Observable that emits some values you specify as arguments,\r\n     * immediately one after the other, and then emits a complete notification.\r\n     *\r\n     * <span class=\"informal\">Emits the arguments you provide, then completes.\r\n     * </span>\r\n     *\r\n     * <img src=\"./img/of.png\" width=\"100%\">\r\n     *\r\n     * This static operator is useful for creating a simple Observable that only\r\n     * emits the arguments given, and the complete notification thereafter. It can\r\n     * be used for composing with other Observables, such as with {@link concat}.\r\n     * By default, it uses a `null` IScheduler, which means the `next`\r\n     * notifications are sent synchronously, although with a different IScheduler\r\n     * it is possible to determine when those notifications will be delivered.\r\n     *\r\n     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\r\n     * var numbers = Rx.Observable.of(10, 20, 30);\r\n     * var letters = Rx.Observable.of('a', 'b', 'c');\r\n     * var interval = Rx.Observable.interval(1000);\r\n     * var result = numbers.concat(letters).concat(interval);\r\n     * result.subscribe(x => console.log(x));\r\n     *\r\n     * @see {@link create}\r\n     * @see {@link empty}\r\n     * @see {@link never}\r\n     * @see {@link throw}\r\n     *\r\n     * @param {...T} values Arguments that represent `next` values to be emitted.\r\n     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\r\n     * the emissions of the `next` notifications.\r\n     * @return {Observable<T>} An Observable that emits each given input value.\r\n     * @static true\r\n     * @name of\r\n     * @owner Observable\r\n     */\r\n    ArrayObservable.of = function () {\r\n        var array = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            array[_i - 0] = arguments[_i];\r\n        }\r\n        var scheduler = array[array.length - 1];\r\n        if (isScheduler(scheduler)) {\r\n            array.pop();\r\n        }\r\n        else {\r\n            scheduler = null;\r\n        }\r\n        var len = array.length;\r\n        if (len > 1) {\r\n            return new ArrayObservable(array, scheduler);\r\n        }\r\n        else if (len === 1) {\r\n            return new ScalarObservable(array[0], scheduler);\r\n        }\r\n        else {\r\n            return new EmptyObservable(scheduler);\r\n        }\r\n    };\r\n    ArrayObservable.dispatch = function (state) {\r\n        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;\r\n        if (index >= count) {\r\n            subscriber.complete();\r\n            return;\r\n        }\r\n        subscriber.next(array[index]);\r\n        if (subscriber.closed) {\r\n            return;\r\n        }\r\n        state.index = index + 1;\r\n        this.schedule(state);\r\n    };\r\n    ArrayObservable.prototype._subscribe = function (subscriber) {\r\n        var index = 0;\r\n        var array = this.array;\r\n        var count = array.length;\r\n        var scheduler = this.scheduler;\r\n        if (scheduler) {\r\n            return scheduler.schedule(ArrayObservable.dispatch, 0, {\r\n                array: array, index: index, count: count, subscriber: subscriber\r\n            });\r\n        }\r\n        else {\r\n            for (var i = 0; i < count && !subscriber.closed; i++) {\r\n                subscriber.next(array[i]);\r\n            }\r\n            subscriber.complete();\r\n        }\r\n    };\r\n    return ArrayObservable;\r\n}(Observable));\r\n//# sourceMappingURL=ArrayObservable.js.map\r\n",null]}