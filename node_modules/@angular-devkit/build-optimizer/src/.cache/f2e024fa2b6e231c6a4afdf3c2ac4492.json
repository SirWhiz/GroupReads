{"remainingRequest":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\xampp\\htdocs\\GroupReads\\node_modules\\rxjs\\_esm5\\observable\\combineLatest.js","dependencies":[{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\rxjs\\_esm5\\observable\\combineLatest.js","mtime":1524743248004},{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1524743208736},{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1524743165754}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START .._util_isScheduler,.._util_isArray,._ArrayObservable,.._operators_combineLatest PURE_IMPORTS_END */\r\nimport { isScheduler } from '../util/isScheduler';\r\nimport { isArray } from '../util/isArray';\r\nimport { ArrayObservable } from './ArrayObservable';\r\nimport { CombineLatestOperator } from '../operators/combineLatest';\r\n/* tslint:enable:max-line-length */\r\n/**\r\n * Combines multiple Observables to create an Observable whose values are\r\n * calculated from the latest values of each of its input Observables.\r\n *\r\n * <span class=\"informal\">Whenever any input Observable emits a value, it\r\n * computes a formula using the latest values from all the inputs, then emits\r\n * the output of that formula.</span>\r\n *\r\n * <img src=\"./img/combineLatest.png\" width=\"100%\">\r\n *\r\n * `combineLatest` combines the values from all the Observables passed as\r\n * arguments. This is done by subscribing to each Observable in order and,\r\n * whenever any Observable emits, collecting an array of the most recent\r\n * values from each Observable. So if you pass `n` Observables to operator,\r\n * returned Observable will always emit an array of `n` values, in order\r\n * corresponding to order of passed Observables (value from the first Observable\r\n * on the first place and so on).\r\n *\r\n * Static version of `combineLatest` accepts either an array of Observables\r\n * or each Observable can be put directly as an argument. Note that array of\r\n * Observables is good choice, if you don't know beforehand how many Observables\r\n * you will combine. Passing empty array will result in Observable that\r\n * completes immediately.\r\n *\r\n * To ensure output array has always the same length, `combineLatest` will\r\n * actually wait for all input Observables to emit at least once,\r\n * before it starts emitting results. This means if some Observable emits\r\n * values before other Observables started emitting, all that values but last\r\n * will be lost. On the other hand, is some Observable does not emit value but\r\n * completes, resulting Observable will complete at the same moment without\r\n * emitting anything, since it will be now impossible to include value from\r\n * completed Observable in resulting array. Also, if some input Observable does\r\n * not emit any value and never completes, `combineLatest` will also never emit\r\n * and never complete, since, again, it will wait for all streams to emit some\r\n * value.\r\n *\r\n * If at least one Observable was passed to `combineLatest` and all passed Observables\r\n * emitted something, resulting Observable will complete when all combined\r\n * streams complete. So even if some Observable completes, result of\r\n * `combineLatest` will still emit values when other Observables do. In case\r\n * of completed Observable, its value from now on will always be the last\r\n * emitted value. On the other hand, if any Observable errors, `combineLatest`\r\n * will error immediately as well, and all other Observables will be unsubscribed.\r\n *\r\n * `combineLatest` accepts as optional parameter `project` function, which takes\r\n * as arguments all values that would normally be emitted by resulting Observable.\r\n * `project` can return any kind of value, which will be then emitted by Observable\r\n * instead of default array. Note that `project` does not take as argument that array\r\n * of values, but values themselves. That means default `project` can be imagined\r\n * as function that takes all its arguments and puts them into an array.\r\n *\r\n *\r\n * @example <caption>Combine two timer Observables</caption>\r\n * const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now\r\n * const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now\r\n * const combinedTimers = Rx.Observable.combineLatest(firstTimer, secondTimer);\r\n * combinedTimers.subscribe(value => console.log(value));\r\n * // Logs\r\n * // [0, 0] after 0.5s\r\n * // [1, 0] after 1s\r\n * // [1, 1] after 1.5s\r\n * // [2, 1] after 2s\r\n *\r\n *\r\n * @example <caption>Combine an array of Observables</caption>\r\n * const observables = [1, 5, 10].map(\r\n *   n => Rx.Observable.of(n).delay(n * 1000).startWith(0) // emit 0 and then emit n after n seconds\r\n * );\r\n * const combined = Rx.Observable.combineLatest(observables);\r\n * combined.subscribe(value => console.log(value));\r\n * // Logs\r\n * // [0, 0, 0] immediately\r\n * // [1, 0, 0] after 1s\r\n * // [1, 5, 0] after 5s\r\n * // [1, 5, 10] after 10s\r\n *\r\n *\r\n * @example <caption>Use project function to dynamically calculate the Body-Mass Index</caption>\r\n * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\r\n * var height = Rx.Observable.of(1.76, 1.77, 1.78);\r\n * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));\r\n * bmi.subscribe(x => console.log('BMI is ' + x));\r\n *\r\n * // With output to console:\r\n * // BMI is 24.212293388429753\r\n * // BMI is 23.93948099205209\r\n * // BMI is 23.671253629592222\r\n *\r\n *\r\n * @see {@link combineAll}\r\n * @see {@link merge}\r\n * @see {@link withLatestFrom}\r\n *\r\n * @param {ObservableInput} observable1 An input Observable to combine with other Observables.\r\n * @param {ObservableInput} observable2 An input Observable to combine with other Observables.\r\n * More than one input Observables may be given as arguments\r\n * or an array of Observables may be given as the first argument.\r\n * @param {function} [project] An optional function to project the values from\r\n * the combined latest values into a new value on the output Observable.\r\n * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\r\n * each input Observable.\r\n * @return {Observable} An Observable of projected values from the most recent\r\n * values from each input Observable, or an array of the most recent values from\r\n * each input Observable.\r\n * @static true\r\n * @name combineLatest\r\n * @owner Observable\r\n */\r\nexport function combineLatest() {\r\n    var observables = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        observables[_i - 0] = arguments[_i];\r\n    }\r\n    var project = null;\r\n    var scheduler = null;\r\n    if (isScheduler(observables[observables.length - 1])) {\r\n        scheduler = observables.pop();\r\n    }\r\n    if (typeof observables[observables.length - 1] === 'function') {\r\n        project = observables.pop();\r\n    }\r\n    // if the first and only other argument besides the resultSelector is an array\r\n    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\r\n    if (observables.length === 1 && isArray(observables[0])) {\r\n        observables = observables[0];\r\n    }\r\n    return new ArrayObservable(observables, scheduler).lift(new CombineLatestOperator(project));\r\n}\r\n//# sourceMappingURL=combineLatest.js.map\r\n",null]}