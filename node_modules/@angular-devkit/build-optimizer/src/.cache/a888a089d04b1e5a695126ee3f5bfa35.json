{"remainingRequest":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\xampp\\htdocs\\GroupReads\\node_modules\\rxjs\\_esm5\\observable\\PromiseObservable.js","dependencies":[{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\rxjs\\_esm5\\observable\\PromiseObservable.js","mtime":1524743247987},{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1524743208736},{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1524743165754}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { root } from '../util/root';\r\nimport { Observable } from '../Observable';\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @extends {Ignored}\r\n * @hide true\r\n */\r\nexport var PromiseObservable = /*@__PURE__*/ (function (_super) {\r\n    __extends(PromiseObservable, _super);\r\n    function PromiseObservable(promise, scheduler) {\r\n        _super.call(this);\r\n        this.promise = promise;\r\n        this.scheduler = scheduler;\r\n    }\r\n    /**\r\n     * Converts a Promise to an Observable.\r\n     *\r\n     * <span class=\"informal\">Returns an Observable that just emits the Promise's\r\n     * resolved value, then completes.</span>\r\n     *\r\n     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\r\n     * Observable. If the Promise resolves with a value, the output Observable\r\n     * emits that resolved value as a `next`, and then completes. If the Promise\r\n     * is rejected, then the output Observable emits the corresponding Error.\r\n     *\r\n     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\r\n     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));\r\n     * result.subscribe(x => console.log(x), e => console.error(e));\r\n     *\r\n     * @see {@link bindCallback}\r\n     * @see {@link from}\r\n     *\r\n     * @param {PromiseLike<T>} promise The promise to be converted.\r\n     * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling\r\n     * the delivery of the resolved value (or the rejection).\r\n     * @return {Observable<T>} An Observable which wraps the Promise.\r\n     * @static true\r\n     * @name fromPromise\r\n     * @owner Observable\r\n     */\r\n    PromiseObservable.create = function (promise, scheduler) {\r\n        return new PromiseObservable(promise, scheduler);\r\n    };\r\n    PromiseObservable.prototype._subscribe = function (subscriber) {\r\n        var _this = this;\r\n        var promise = this.promise;\r\n        var scheduler = this.scheduler;\r\n        if (scheduler == null) {\r\n            if (this._isScalar) {\r\n                if (!subscriber.closed) {\r\n                    subscriber.next(this.value);\r\n                    subscriber.complete();\r\n                }\r\n            }\r\n            else {\r\n                promise.then(function (value) {\r\n                    _this.value = value;\r\n                    _this._isScalar = true;\r\n                    if (!subscriber.closed) {\r\n                        subscriber.next(value);\r\n                        subscriber.complete();\r\n                    }\r\n                }, function (err) {\r\n                    if (!subscriber.closed) {\r\n                        subscriber.error(err);\r\n                    }\r\n                })\r\n                    .then(null, function (err) {\r\n                    // escape the promise trap, throw unhandled errors\r\n                    root.setTimeout(function () { throw err; });\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            if (this._isScalar) {\r\n                if (!subscriber.closed) {\r\n                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });\r\n                }\r\n            }\r\n            else {\r\n                promise.then(function (value) {\r\n                    _this.value = value;\r\n                    _this._isScalar = true;\r\n                    if (!subscriber.closed) {\r\n                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));\r\n                    }\r\n                }, function (err) {\r\n                    if (!subscriber.closed) {\r\n                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));\r\n                    }\r\n                })\r\n                    .then(null, function (err) {\r\n                    // escape the promise trap, throw unhandled errors\r\n                    root.setTimeout(function () { throw err; });\r\n                });\r\n            }\r\n        }\r\n    };\r\n    return PromiseObservable;\r\n}(Observable));\r\nfunction dispatchNext(arg) {\r\n    var value = arg.value, subscriber = arg.subscriber;\r\n    if (!subscriber.closed) {\r\n        subscriber.next(value);\r\n        subscriber.complete();\r\n    }\r\n}\r\nfunction dispatchError(arg) {\r\n    var err = arg.err, subscriber = arg.subscriber;\r\n    if (!subscriber.closed) {\r\n        subscriber.error(err);\r\n    }\r\n}\r\n//# sourceMappingURL=PromiseObservable.js.map\r\n",null]}