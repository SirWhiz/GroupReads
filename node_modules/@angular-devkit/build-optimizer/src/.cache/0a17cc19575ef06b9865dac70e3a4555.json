{"remainingRequest":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\xampp\\htdocs\\GroupReads\\node_modules\\rxjs\\_esm5\\observable\\ConnectableObservable.js","dependencies":[{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\rxjs\\_esm5\\observable\\ConnectableObservable.js","mtime":1524743247955},{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1524743208736},{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1524743165754}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { SubjectSubscriber } from '../Subject';\r\nimport { Observable } from '../Observable';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { Subscription } from '../Subscription';\r\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\r\n/**\r\n * @class ConnectableObservable<T>\r\n */\r\nexport var ConnectableObservable = /*@__PURE__*/ (function (_super) {\r\n    __extends(ConnectableObservable, _super);\r\n    function ConnectableObservable(source, subjectFactory) {\r\n        _super.call(this);\r\n        this.source = source;\r\n        this.subjectFactory = subjectFactory;\r\n        this._refCount = 0;\r\n        this._isComplete = false;\r\n    }\r\n    ConnectableObservable.prototype._subscribe = function (subscriber) {\r\n        return this.getSubject().subscribe(subscriber);\r\n    };\r\n    ConnectableObservable.prototype.getSubject = function () {\r\n        var subject = this._subject;\r\n        if (!subject || subject.isStopped) {\r\n            this._subject = this.subjectFactory();\r\n        }\r\n        return this._subject;\r\n    };\r\n    ConnectableObservable.prototype.connect = function () {\r\n        var connection = this._connection;\r\n        if (!connection) {\r\n            this._isComplete = false;\r\n            connection = this._connection = new Subscription();\r\n            connection.add(this.source\r\n                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\r\n            if (connection.closed) {\r\n                this._connection = null;\r\n                connection = Subscription.EMPTY;\r\n            }\r\n            else {\r\n                this._connection = connection;\r\n            }\r\n        }\r\n        return connection;\r\n    };\r\n    ConnectableObservable.prototype.refCount = function () {\r\n        return higherOrderRefCount()(this);\r\n    };\r\n    return ConnectableObservable;\r\n}(Observable));\r\nvar connectableProto = ConnectableObservable.prototype;\r\nexport var connectableObservableDescriptor = {\r\n    operator: { value: null },\r\n    _refCount: { value: 0, writable: true },\r\n    _subject: { value: null, writable: true },\r\n    _connection: { value: null, writable: true },\r\n    _subscribe: { value: connectableProto._subscribe },\r\n    _isComplete: { value: connectableProto._isComplete, writable: true },\r\n    getSubject: { value: connectableProto.getSubject },\r\n    connect: { value: connectableProto.connect },\r\n    refCount: { value: connectableProto.refCount }\r\n};\r\nvar ConnectableSubscriber = /*@__PURE__*/ (function (_super) {\r\n    __extends(ConnectableSubscriber, _super);\r\n    function ConnectableSubscriber(destination, connectable) {\r\n        _super.call(this, destination);\r\n        this.connectable = connectable;\r\n    }\r\n    ConnectableSubscriber.prototype._error = function (err) {\r\n        this._unsubscribe();\r\n        _super.prototype._error.call(this, err);\r\n    };\r\n    ConnectableSubscriber.prototype._complete = function () {\r\n        this.connectable._isComplete = true;\r\n        this._unsubscribe();\r\n        _super.prototype._complete.call(this);\r\n    };\r\n    ConnectableSubscriber.prototype._unsubscribe = function () {\r\n        var connectable = this.connectable;\r\n        if (connectable) {\r\n            this.connectable = null;\r\n            var connection = connectable._connection;\r\n            connectable._refCount = 0;\r\n            connectable._subject = null;\r\n            connectable._connection = null;\r\n            if (connection) {\r\n                connection.unsubscribe();\r\n            }\r\n        }\r\n    };\r\n    return ConnectableSubscriber;\r\n}(SubjectSubscriber));\r\nvar RefCountOperator = /*@__PURE__*/ (function () {\r\n    function RefCountOperator(connectable) {\r\n        this.connectable = connectable;\r\n    }\r\n    RefCountOperator.prototype.call = function (subscriber, source) {\r\n        var connectable = this.connectable;\r\n        connectable._refCount++;\r\n        var refCounter = new RefCountSubscriber(subscriber, connectable);\r\n        var subscription = source.subscribe(refCounter);\r\n        if (!refCounter.closed) {\r\n            refCounter.connection = connectable.connect();\r\n        }\r\n        return subscription;\r\n    };\r\n    return RefCountOperator;\r\n}());\r\nvar RefCountSubscriber = /*@__PURE__*/ (function (_super) {\r\n    __extends(RefCountSubscriber, _super);\r\n    function RefCountSubscriber(destination, connectable) {\r\n        _super.call(this, destination);\r\n        this.connectable = connectable;\r\n    }\r\n    RefCountSubscriber.prototype._unsubscribe = function () {\r\n        var connectable = this.connectable;\r\n        if (!connectable) {\r\n            this.connection = null;\r\n            return;\r\n        }\r\n        this.connectable = null;\r\n        var refCount = connectable._refCount;\r\n        if (refCount <= 0) {\r\n            this.connection = null;\r\n            return;\r\n        }\r\n        connectable._refCount = refCount - 1;\r\n        if (refCount > 1) {\r\n            this.connection = null;\r\n            return;\r\n        }\r\n        ///\r\n        // Compare the local RefCountSubscriber's connection Subscription to the\r\n        // connection Subscription on the shared ConnectableObservable. In cases\r\n        // where the ConnectableObservable source synchronously emits values, and\r\n        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\r\n        // execution continues to here before the RefCountOperator has a chance to\r\n        // supply the RefCountSubscriber with the shared connection Subscription.\r\n        // For example:\r\n        // ```\r\n        // Observable.range(0, 10)\r\n        //   .publish()\r\n        //   .refCount()\r\n        //   .take(5)\r\n        //   .subscribe();\r\n        // ```\r\n        // In order to account for this case, RefCountSubscriber should only dispose\r\n        // the ConnectableObservable's shared connection Subscription if the\r\n        // connection Subscription exists, *and* either:\r\n        //   a. RefCountSubscriber doesn't have a reference to the shared connection\r\n        //      Subscription yet, or,\r\n        //   b. RefCountSubscriber's connection Subscription reference is identical\r\n        //      to the shared connection Subscription\r\n        ///\r\n        var connection = this.connection;\r\n        var sharedConnection = connectable._connection;\r\n        this.connection = null;\r\n        if (sharedConnection && (!connection || sharedConnection === connection)) {\r\n            sharedConnection.unsubscribe();\r\n        }\r\n    };\r\n    return RefCountSubscriber;\r\n}(Subscriber));\r\n//# sourceMappingURL=ConnectableObservable.js.map\r\n",null]}