{"remainingRequest":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\xampp\\htdocs\\GroupReads\\node_modules\\rxjs\\_esm5\\observable\\ForkJoinObservable.js","dependencies":[{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\rxjs\\_esm5\\observable\\ForkJoinObservable.js","mtime":1524743247965},{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1524743208736},{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1524743165754}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { Observable } from '../Observable';\r\nimport { EmptyObservable } from './EmptyObservable';\r\nimport { isArray } from '../util/isArray';\r\nimport { subscribeToResult } from '../util/subscribeToResult';\r\nimport { OuterSubscriber } from '../OuterSubscriber';\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @extends {Ignored}\r\n * @hide true\r\n */\r\nexport var ForkJoinObservable = /*@__PURE__*/ (function (_super) {\r\n    __extends(ForkJoinObservable, _super);\r\n    function ForkJoinObservable(sources, resultSelector) {\r\n        _super.call(this);\r\n        this.sources = sources;\r\n        this.resultSelector = resultSelector;\r\n    }\r\n    /* tslint:enable:max-line-length */\r\n    /**\r\n     * Joins last values emitted by passed Observables.\r\n     *\r\n     * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted.</span>\r\n     *\r\n     * <img src=\"./img/forkJoin.png\" width=\"100%\">\r\n     *\r\n     * `forkJoin` is an operator that takes any number of Observables which can be passed either as an array\r\n     * or directly as arguments. If no input Observables are provided, resulting stream will complete\r\n     * immediately.\r\n     *\r\n     * `forkJoin` will wait for all passed Observables to complete and then it will emit an array with last\r\n     * values from corresponding Observables. So if you pass `n` Observables to the operator, resulting\r\n     * array will have `n` values, where first value is the last thing emitted by the first Observable,\r\n     * second value is the last thing emitted by the second Observable and so on. That means `forkJoin` will\r\n     * not emit more than once and it will complete after that. If you need to emit combined values not only\r\n     * at the end of lifecycle of passed Observables, but also throughout it, try out {@link combineLatest}\r\n     * or {@link zip} instead.\r\n     *\r\n     * In order for resulting array to have the same length as the number of input Observables, whenever any of\r\n     * that Observables completes without emitting any value, `forkJoin` will complete at that moment as well\r\n     * and it will not emit anything either, even if it already has some last values from other Observables.\r\n     * Conversely, if there is an Observable that never completes, `forkJoin` will never complete as well,\r\n     * unless at any point some other Observable completes without emitting value, which brings us back to\r\n     * the previous case. Overall, in order for `forkJoin` to emit a value, all Observables passed as arguments\r\n     * have to emit something at least once and complete.\r\n     *\r\n     * If any input Observable errors at some point, `forkJoin` will error as well and all other Observables\r\n     * will be immediately unsubscribed.\r\n     *\r\n     * Optionally `forkJoin` accepts project function, that will be called with values which normally\r\n     * would land in emitted array. Whatever is returned by project function, will appear in output\r\n     * Observable instead. This means that default project can be thought of as a function that takes\r\n     * all its arguments and puts them into an array. Note that project function will be called only\r\n     * when output Observable is supposed to emit a result.\r\n     *\r\n     * @example <caption>Use forkJoin with operator emitting immediately</caption>\r\n     * const observable = Rx.Observable.forkJoin(\r\n     *   Rx.Observable.of(1, 2, 3, 4),\r\n     *   Rx.Observable.of(5, 6, 7, 8)\r\n     * );\r\n     * observable.subscribe(\r\n     *   value => console.log(value),\r\n     *   err => {},\r\n     *   () => console.log('This is how it ends!')\r\n     * );\r\n     *\r\n     * // Logs:\r\n     * // [4, 8]\r\n     * // \"This is how it ends!\"\r\n     *\r\n     *\r\n     * @example <caption>Use forkJoin with operator emitting after some time</caption>\r\n     * const observable = Rx.Observable.forkJoin(\r\n     *   Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\r\n     *   Rx.Observable.interval(500).take(4) // emit 0, 1, 2, 3 every half a second and complete\r\n     * );\r\n     * observable.subscribe(\r\n     *   value => console.log(value),\r\n     *   err => {},\r\n     *   () => console.log('This is how it ends!')\r\n     * );\r\n     *\r\n     * // Logs:\r\n     * // [2, 3] after 3 seconds\r\n     * // \"This is how it ends!\" immediately after\r\n     *\r\n     *\r\n     * @example <caption>Use forkJoin with project function</caption>\r\n     * const observable = Rx.Observable.forkJoin(\r\n     *   Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\r\n     *   Rx.Observable.interval(500).take(4), // emit 0, 1, 2, 3 every half a second and complete\r\n     *   (n, m) => n + m\r\n     * );\r\n     * observable.subscribe(\r\n     *   value => console.log(value),\r\n     *   err => {},\r\n     *   () => console.log('This is how it ends!')\r\n     * );\r\n     *\r\n     * // Logs:\r\n     * // 5 after 3 seconds\r\n     * // \"This is how it ends!\" immediately after\r\n     *\r\n     * @see {@link combineLatest}\r\n     * @see {@link zip}\r\n     *\r\n     * @param {...SubscribableOrPromise} sources Any number of Observables provided either as an array or as an arguments\r\n     * passed directly to the operator.\r\n     * @param {function} [project] Function that takes values emitted by input Observables and returns value\r\n     * that will appear in resulting Observable instead of default array.\r\n     * @return {Observable} Observable emitting either an array of last values emitted by passed Observables\r\n     * or value from project function.\r\n     * @static true\r\n     * @name forkJoin\r\n     * @owner Observable\r\n     */\r\n    ForkJoinObservable.create = function () {\r\n        var sources = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            sources[_i - 0] = arguments[_i];\r\n        }\r\n        if (sources === null || arguments.length === 0) {\r\n            return new EmptyObservable();\r\n        }\r\n        var resultSelector = null;\r\n        if (typeof sources[sources.length - 1] === 'function') {\r\n            resultSelector = sources.pop();\r\n        }\r\n        // if the first and only other argument besides the resultSelector is an array\r\n        // assume it's been called with `forkJoin([obs1, obs2, obs3], resultSelector)`\r\n        if (sources.length === 1 && isArray(sources[0])) {\r\n            sources = sources[0];\r\n        }\r\n        if (sources.length === 0) {\r\n            return new EmptyObservable();\r\n        }\r\n        return new ForkJoinObservable(sources, resultSelector);\r\n    };\r\n    ForkJoinObservable.prototype._subscribe = function (subscriber) {\r\n        return new ForkJoinSubscriber(subscriber, this.sources, this.resultSelector);\r\n    };\r\n    return ForkJoinObservable;\r\n}(Observable));\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nvar ForkJoinSubscriber = /*@__PURE__*/ (function (_super) {\r\n    __extends(ForkJoinSubscriber, _super);\r\n    function ForkJoinSubscriber(destination, sources, resultSelector) {\r\n        _super.call(this, destination);\r\n        this.sources = sources;\r\n        this.resultSelector = resultSelector;\r\n        this.completed = 0;\r\n        this.haveValues = 0;\r\n        var len = sources.length;\r\n        this.total = len;\r\n        this.values = new Array(len);\r\n        for (var i = 0; i < len; i++) {\r\n            var source = sources[i];\r\n            var innerSubscription = subscribeToResult(this, source, null, i);\r\n            if (innerSubscription) {\r\n                innerSubscription.outerIndex = i;\r\n                this.add(innerSubscription);\r\n            }\r\n        }\r\n    }\r\n    ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\r\n        this.values[outerIndex] = innerValue;\r\n        if (!innerSub._hasValue) {\r\n            innerSub._hasValue = true;\r\n            this.haveValues++;\r\n        }\r\n    };\r\n    ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {\r\n        var destination = this.destination;\r\n        var _a = this, haveValues = _a.haveValues, resultSelector = _a.resultSelector, values = _a.values;\r\n        var len = values.length;\r\n        if (!innerSub._hasValue) {\r\n            destination.complete();\r\n            return;\r\n        }\r\n        this.completed++;\r\n        if (this.completed !== len) {\r\n            return;\r\n        }\r\n        if (haveValues === len) {\r\n            var value = resultSelector ? resultSelector.apply(this, values) : values;\r\n            destination.next(value);\r\n        }\r\n        destination.complete();\r\n    };\r\n    return ForkJoinSubscriber;\r\n}(OuterSubscriber));\r\n//# sourceMappingURL=ForkJoinObservable.js.map\r\n",null]}