{"remainingRequest":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular\\cdk\\esm5\\overlay.es5.js","dependencies":[{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular\\cdk\\esm5\\overlay.es5.js","mtime":1524743166831},{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1524743208736},{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1524743165754}],"contextDependencies":[],"result":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** PURE_IMPORTS_START _angular_core,_angular_cdk_scrolling,_angular_common,_angular_cdk_bidi,_angular_cdk_portal,tslib,tslib,rxjs_operators_take,rxjs_Subject,rxjs_Subscription,rxjs_operators_filter,rxjs_observable_fromEvent,_angular_cdk_coercion,_angular_cdk_keycodes PURE_IMPORTS_END */\nimport { ApplicationRef, ComponentFactoryResolver, Directive, ElementRef, EventEmitter, Inject, Injectable, InjectionToken, Injector, Input, NgModule, NgZone, Optional, Output, SkipSelf, TemplateRef, ViewContainerRef } from '@angular/core';\nimport { CdkScrollable, ScrollDispatchModule, ScrollDispatcher, VIEWPORT_RULER_PROVIDER, ViewportRuler } from '@angular/cdk/scrolling';\nimport { DOCUMENT } from '@angular/common';\nimport { BidiModule, Directionality } from '@angular/cdk/bidi';\nimport { DomPortalOutlet, PortalModule, TemplatePortal } from '@angular/cdk/portal';\nimport { __assign, __extends } from 'tslib';\nimport { take } from 'rxjs/operators/take';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport { filter } from 'rxjs/operators/filter';\nimport { fromEvent } from 'rxjs/observable/fromEvent';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ESCAPE } from '@angular/cdk/keycodes';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Scroll strategy that doesn't do anything.\n */\nvar NoopScrollStrategy = /*@__PURE__*/ (function () {\n    function NoopScrollStrategy() {\n    }\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.enable = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n        function () { };\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.disable = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n        function () { };\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.attach = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n        function () { };\n    return NoopScrollStrategy;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Initial configuration used when creating an overlay.\n */\nvar OverlayConfig = /*@__PURE__*/ (function () {\n    function OverlayConfig(config) {\n        var _this = this;\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = new NoopScrollStrategy();\n        /**\n         * Custom class to add to the overlay pane.\n         */\n        this.panelClass = '';\n        /**\n         * Whether the overlay has a backdrop.\n         */\n        this.hasBackdrop = false;\n        /**\n         * Custom class to add to the backdrop\n         */\n        this.backdropClass = 'cdk-overlay-dark-backdrop';\n        /**\n         * The direction of the text in the overlay panel.\n         */\n        this.direction = 'ltr';\n        if (config) {\n            Object.keys(config)\n                .filter(function (key) { return typeof config[key] !== 'undefined'; })\n                .forEach(function (key) { return _this[key] = config[key]; });\n        }\n    }\n    return OverlayConfig;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * A connection point on the origin element.\n * @record\n */\n/**\n * A connection point on the overlay element.\n * @record\n */\n/**\n * The points of the origin element and the overlay element to connect.\n */\nvar ConnectionPositionPair = /*@__PURE__*/ (function () {\n    function ConnectionPositionPair(origin, overlay, offsetX, offsetY) {\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.originX = origin.originX;\n        this.originY = origin.originY;\n        this.overlayX = overlay.overlayX;\n        this.overlayY = overlay.overlayY;\n    }\n    return ConnectionPositionPair;\n}());\n/**\n * Set of properties regarding the position of the origin and overlay relative to the viewport\n * with respect to the containing Scrollable elements.\n *\n * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\n * bounds of any one of the strategy's Scrollable's bounding client rectangle.\n *\n * The overlay and origin are outside view if there is no overlap between their bounding client\n * rectangle and any one of the strategy's Scrollable's bounding client rectangle.\n *\n *       -----------                    -----------\n *       | outside |                    | clipped |\n *       |  view   |              --------------------------\n *       |         |              |     |         |        |\n *       ----------               |     -----------        |\n *  --------------------------    |                        |\n *  |                        |    |      Scrollable        |\n *  |                        |    |                        |\n *  |                        |     --------------------------\n *  |      Scrollable        |\n *  |                        |\n *  --------------------------\n *\n *  \\@docs-private\n */\nvar ScrollingVisibility = /*@__PURE__*/ (function () {\n    function ScrollingVisibility() {\n    }\n    return ScrollingVisibility;\n}());\n/**\n * The change event emitted by the strategy when a fallback position is used.\n */\nvar ConnectedOverlayPositionChange = /*@__PURE__*/ (function () {\n    function ConnectedOverlayPositionChange(connectionPair, /** @docs-private */ scrollableViewProperties) {\n        this.connectionPair = connectionPair;\n        this.scrollableViewProperties = scrollableViewProperties;\n    }\n    return ConnectedOverlayPositionChange;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Describes a strategy that will be used by an overlay to handle scroll events while it is open.\n * @record\n */\n/**\n * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\n * @return {?}\n */\nfunction getMatScrollStrategyAlreadyAttachedError() {\n    return Error(\"Scroll strategy has already been attached.\");\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Config options for the CloseScrollStrategy.\n * @record\n */\n/**\n * Strategy that will close the overlay as soon as the user starts scrolling.\n */\nvar CloseScrollStrategy = /*@__PURE__*/ (function () {\n    function CloseScrollStrategy(_scrollDispatcher, _ngZone, _viewportRuler, _config) {\n        var _this = this;\n        this._scrollDispatcher = _scrollDispatcher;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._config = _config;\n        this._scrollSubscription = null;\n        /**\n         * Detaches the overlay ref and disables the scroll strategy.\n         */\n        this._detach = function () {\n            _this.disable();\n            if (_this._overlayRef.hasAttached()) {\n                _this._ngZone.run(function () { return _this._overlayRef.detach(); });\n            }\n        };\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n        function (overlayRef) {\n            if (this._overlayRef) {\n                throw getMatScrollStrategyAlreadyAttachedError();\n            }\n            this._overlayRef = overlayRef;\n        };\n    /** Enables the closing of the attached overlay on scroll. */\n    /**\n     * Enables the closing of the attached overlay on scroll.\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.enable = /**\n     * Enables the closing of the attached overlay on scroll.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this._scrollSubscription) {\n                return;\n            }\n            var /** @type {?} */ stream = this._scrollDispatcher.scrolled(0);\n            if (this._config && this._config.threshold && this._config.threshold > 1) {\n                this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n                this._scrollSubscription = stream.subscribe(function () {\n                    var /** @type {?} */ scrollPosition = _this._viewportRuler.getViewportScrollPosition().top;\n                    if (Math.abs(scrollPosition - _this._initialScrollPosition) > /** @type {?} */ ((((_this._config)).threshold))) {\n                        _this._detach();\n                    }\n                    else {\n                        _this._overlayRef.updatePosition();\n                    }\n                });\n            }\n            else {\n                this._scrollSubscription = stream.subscribe(this._detach);\n            }\n        };\n    /** Disables the closing the attached overlay on scroll. */\n    /**\n     * Disables the closing the attached overlay on scroll.\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.disable = /**\n     * Disables the closing the attached overlay on scroll.\n     * @return {?}\n     */\n        function () {\n            if (this._scrollSubscription) {\n                this._scrollSubscription.unsubscribe();\n                this._scrollSubscription = null;\n            }\n        };\n    return CloseScrollStrategy;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Strategy that will prevent the user from scrolling while the overlay is visible.\n */\nvar BlockScrollStrategy = /*@__PURE__*/ (function () {\n    function BlockScrollStrategy(_viewportRuler, document) {\n        this._viewportRuler = _viewportRuler;\n        this._previousHTMLStyles = { top: '', left: '' };\n        this._isEnabled = false;\n        this._document = document;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @return {?}\n     */\n        function () { };\n    /** Blocks page-level scroll while the attached overlay is open. */\n    /**\n     * Blocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.enable = /**\n     * Blocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n        function () {\n            if (this._canBeEnabled()) {\n                var /** @type {?} */ root = this._document.documentElement;\n                this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\n                // Cache the previous inline styles in case the user had set them.\n                this._previousHTMLStyles.left = root.style.left || '';\n                this._previousHTMLStyles.top = root.style.top || '';\n                // Note: we're using the `html` node, instead of the `body`, because the `body` may\n                // have the user agent margin, whereas the `html` is guaranteed not to have one.\n                root.style.left = -this._previousScrollPosition.left + \"px\";\n                root.style.top = -this._previousScrollPosition.top + \"px\";\n                root.classList.add('cdk-global-scrollblock');\n                this._isEnabled = true;\n            }\n        };\n    /** Unblocks page-level scroll while the attached overlay is open. */\n    /**\n     * Unblocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.disable = /**\n     * Unblocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n        function () {\n            if (this._isEnabled) {\n                var /** @type {?} */ html = this._document.documentElement;\n                var /** @type {?} */ body = this._document.body;\n                var /** @type {?} */ previousHtmlScrollBehavior = html.style['scrollBehavior'] || '';\n                var /** @type {?} */ previousBodyScrollBehavior = body.style['scrollBehavior'] || '';\n                this._isEnabled = false;\n                html.style.left = this._previousHTMLStyles.left;\n                html.style.top = this._previousHTMLStyles.top;\n                html.classList.remove('cdk-global-scrollblock');\n                // Disable user-defined smooth scrolling temporarily while we restore the scroll position.\n                // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\n                html.style['scrollBehavior'] = body.style['scrollBehavior'] = 'auto';\n                window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\n                html.style['scrollBehavior'] = previousHtmlScrollBehavior;\n                body.style['scrollBehavior'] = previousBodyScrollBehavior;\n            }\n        };\n    /**\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype._canBeEnabled = /**\n     * @return {?}\n     */\n        function () {\n            // Since the scroll strategies can't be singletons, we have to use a global CSS class\n            // (`cdk-global-scrollblock`) to make sure that we don't try to disable global\n            // scrolling multiple times.\n            var /** @type {?} */ html = this._document.documentElement;\n            if (html.classList.contains('cdk-global-scrollblock') || this._isEnabled) {\n                return false;\n            }\n            var /** @type {?} */ body = this._document.body;\n            var /** @type {?} */ viewport = this._viewportRuler.getViewportSize();\n            return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\n        };\n    return BlockScrollStrategy;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n// TODO(jelbourn): move this to live with the rest of the scrolling code\n// TODO(jelbourn): someday replace this with IntersectionObservers\n/**\n * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is scrolled out of view\n */\nfunction isElementScrolledOutsideView(element, scrollContainers) {\n    return scrollContainers.some(function (containerBounds) {\n        var /** @type {?} */ outsideAbove = element.bottom < containerBounds.top;\n        var /** @type {?} */ outsideBelow = element.top > containerBounds.bottom;\n        var /** @type {?} */ outsideLeft = element.right < containerBounds.left;\n        var /** @type {?} */ outsideRight = element.left > containerBounds.right;\n        return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n    });\n}\n/**\n * Gets whether an element is clipped by any of its scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is clipped\n */\nfunction isElementClippedByScrolling(element, scrollContainers) {\n    return scrollContainers.some(function (scrollContainerRect) {\n        var /** @type {?} */ clippedAbove = element.top < scrollContainerRect.top;\n        var /** @type {?} */ clippedBelow = element.bottom > scrollContainerRect.bottom;\n        var /** @type {?} */ clippedLeft = element.left < scrollContainerRect.left;\n        var /** @type {?} */ clippedRight = element.right > scrollContainerRect.right;\n        return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n    });\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Config options for the RepositionScrollStrategy.\n * @record\n */\n/**\n * Strategy that will update the element position as the user is scrolling.\n */\nvar RepositionScrollStrategy = /*@__PURE__*/ (function () {\n    function RepositionScrollStrategy(_scrollDispatcher, _viewportRuler, _ngZone, _config) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        this._config = _config;\n        this._scrollSubscription = null;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n        function (overlayRef) {\n            if (this._overlayRef) {\n                throw getMatScrollStrategyAlreadyAttachedError();\n            }\n            this._overlayRef = overlayRef;\n        };\n    /** Enables repositioning of the attached overlay on scroll. */\n    /**\n     * Enables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.enable = /**\n     * Enables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (!this._scrollSubscription) {\n                var /** @type {?} */ throttle = this._config ? this._config.scrollThrottle : 0;\n                this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(function () {\n                    _this._overlayRef.updatePosition();\n                    // TODO(crisbeto): make `close` on by default once all components can handle it.\n                    if (_this._config && _this._config.autoClose) {\n                        var /** @type {?} */ overlayRect = _this._overlayRef.overlayElement.getBoundingClientRect();\n                        var _a = _this._viewportRuler.getViewportSize(), width = _a.width, height = _a.height;\n                        // TODO(crisbeto): include all ancestor scroll containers here once\n                        // we have a way of exposing the trigger element to the scroll strategy.\n                        var /** @type {?} */ parentRects = [{ width: width, height: height, bottom: height, right: width, top: 0, left: 0 }];\n                        if (isElementScrolledOutsideView(overlayRect, parentRects)) {\n                            _this.disable();\n                            _this._ngZone.run(function () { return _this._overlayRef.detach(); });\n                        }\n                    }\n                });\n            }\n        };\n    /** Disables repositioning of the attached overlay on scroll. */\n    /**\n     * Disables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.disable = /**\n     * Disables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n        function () {\n            if (this._scrollSubscription) {\n                this._scrollSubscription.unsubscribe();\n                this._scrollSubscription = null;\n            }\n        };\n    return RepositionScrollStrategy;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Options for how an overlay will handle scrolling.\n *\n * Users can provide a custom value for `ScrollStrategyOptions` to replace the default\n * behaviors. This class primarily acts as a factory for ScrollStrategy instances.\n */\nvar ScrollStrategyOptions = /*@__PURE__*/ (function () {\n    function ScrollStrategyOptions(_scrollDispatcher, _viewportRuler, _ngZone, document) {\n        var _this = this;\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        /**\n         * Do nothing on scroll.\n         */\n        this.noop = function () { return new NoopScrollStrategy(); };\n        /**\n         * Close the overlay as soon as the user scrolls.\n         * @param config Configuration to be used inside the scroll strategy.\n         */\n        this.close = function (config) {\n            return new CloseScrollStrategy(_this._scrollDispatcher, _this._ngZone, _this._viewportRuler, config);\n        };\n        /**\n         * Block scrolling.\n         */\n        this.block = function () { return new BlockScrollStrategy(_this._viewportRuler, _this._document); };\n        /**\n         * Update the overlay's position on scroll.\n         * @param config Configuration to be used inside the scroll strategy.\n         * Allows debouncing the reposition calls.\n         */\n        this.reposition = function (config) {\n            return new RepositionScrollStrategy(_this._scrollDispatcher, _this._viewportRuler, _this._ngZone, config);\n        };\n        this._document = document;\n    }\n    return ScrollStrategyOptions;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nvar OverlayRef = /*@__PURE__*/ (function () {\n    function OverlayRef(_portalOutlet, _pane, _config, _ngZone, _keyboardDispatcher, _document) {\n        this._portalOutlet = _portalOutlet;\n        this._pane = _pane;\n        this._config = _config;\n        this._ngZone = _ngZone;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._document = _document;\n        this._backdropElement = null;\n        this._backdropClick = new Subject();\n        this._attachments = new Subject();\n        this._detachments = new Subject();\n        /**\n         * Stream of keydown events dispatched to this overlay.\n         */\n        this._keydownEvents = new Subject();\n        if (_config.scrollStrategy) {\n            _config.scrollStrategy.attach(this);\n        }\n    }\n    Object.defineProperty(OverlayRef.prototype, \"overlayElement\", {\n        /** The overlay's HTML element */\n        get: /**\n         * The overlay's HTML element\n         * @return {?}\n         */ function () {\n            return this._pane;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(OverlayRef.prototype, \"backdropElement\", {\n        /** The overlay's backdrop HTML element. */\n        get: /**\n         * The overlay's backdrop HTML element.\n         * @return {?}\n         */ function () {\n            return this._backdropElement;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param portal Portal instance to which to attach the overlay.\n     * @returns The portal attachment result.\n     */\n    /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n    OverlayRef.prototype.attach = /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n        function (portal) {\n            var _this = this;\n            var /** @type {?} */ attachResult = this._portalOutlet.attach(portal);\n            if (this._config.positionStrategy) {\n                this._config.positionStrategy.attach(this);\n            }\n            // Update the pane element with the given configuration.\n            this._updateStackingOrder();\n            this._updateElementSize();\n            this._updateElementDirection();\n            if (this._config.scrollStrategy) {\n                this._config.scrollStrategy.enable();\n            }\n            // Update the position once the zone is stable so that the overlay will be fully rendered\n            // before attempting to position it, as the position may depend on the size of the rendered\n            // content.\n            this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(function () {\n                // The overlay could've been detached before the zone has stabilized.\n                if (_this.hasAttached()) {\n                    _this.updatePosition();\n                }\n            });\n            // Enable pointer events for the overlay pane element.\n            this._togglePointerEvents(true);\n            if (this._config.hasBackdrop) {\n                this._attachBackdrop();\n            }\n            if (this._config.panelClass) {\n                // We can't do a spread here, because IE doesn't support setting multiple classes.\n                if (Array.isArray(this._config.panelClass)) {\n                    this._config.panelClass.forEach(function (cls) { return _this._pane.classList.add(cls); });\n                }\n                else {\n                    this._pane.classList.add(this._config.panelClass);\n                }\n            }\n            // Only emit the `attachments` event once all other setup is done.\n            this._attachments.next();\n            // Track this overlay by the keyboard dispatcher\n            this._keyboardDispatcher.add(this);\n            return attachResult;\n        };\n    /**\n     * Detaches an overlay from a portal.\n     * @returns The portal detachment result.\n     */\n    /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n    OverlayRef.prototype.detach = /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n        function () {\n            if (!this.hasAttached()) {\n                return;\n            }\n            this.detachBackdrop();\n            // When the overlay is detached, the pane element should disable pointer events.\n            // This is necessary because otherwise the pane element will cover the page and disable\n            // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\n            this._togglePointerEvents(false);\n            if (this._config.positionStrategy && this._config.positionStrategy.detach) {\n                this._config.positionStrategy.detach();\n            }\n            if (this._config.scrollStrategy) {\n                this._config.scrollStrategy.disable();\n            }\n            var /** @type {?} */ detachmentResult = this._portalOutlet.detach();\n            // Only emit after everything is detached.\n            this._detachments.next();\n            // Remove this overlay from keyboard dispatcher tracking\n            this._keyboardDispatcher.remove(this);\n            return detachmentResult;\n        };\n    /** Cleans up the overlay from the DOM. */\n    /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n    OverlayRef.prototype.dispose = /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n        function () {\n            var /** @type {?} */ isAttached = this.hasAttached();\n            if (this._config.positionStrategy) {\n                this._config.positionStrategy.dispose();\n            }\n            if (this._config.scrollStrategy) {\n                this._config.scrollStrategy.disable();\n            }\n            this.detachBackdrop();\n            this._keyboardDispatcher.remove(this);\n            this._portalOutlet.dispose();\n            this._attachments.complete();\n            this._backdropClick.complete();\n            this._keydownEvents.complete();\n            if (isAttached) {\n                this._detachments.next();\n            }\n            this._detachments.complete();\n        };\n    /** Whether the overlay has attached content. */\n    /**\n     * Whether the overlay has attached content.\n     * @return {?}\n     */\n    OverlayRef.prototype.hasAttached = /**\n     * Whether the overlay has attached content.\n     * @return {?}\n     */\n        function () {\n            return this._portalOutlet.hasAttached();\n        };\n    /** Gets an observable that emits when the backdrop has been clicked. */\n    /**\n     * Gets an observable that emits when the backdrop has been clicked.\n     * @return {?}\n     */\n    OverlayRef.prototype.backdropClick = /**\n     * Gets an observable that emits when the backdrop has been clicked.\n     * @return {?}\n     */\n        function () {\n            return this._backdropClick.asObservable();\n        };\n    /** Gets an observable that emits when the overlay has been attached. */\n    /**\n     * Gets an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n    OverlayRef.prototype.attachments = /**\n     * Gets an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n        function () {\n            return this._attachments.asObservable();\n        };\n    /** Gets an observable that emits when the overlay has been detached. */\n    /**\n     * Gets an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachments = /**\n     * Gets an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n        function () {\n            return this._detachments.asObservable();\n        };\n    /** Gets an observable of keydown events targeted to this overlay. */\n    /**\n     * Gets an observable of keydown events targeted to this overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.keydownEvents = /**\n     * Gets an observable of keydown events targeted to this overlay.\n     * @return {?}\n     */\n        function () {\n            return this._keydownEvents.asObservable();\n        };\n    /** Gets the the current overlay configuration, which is immutable. */\n    /**\n     * Gets the the current overlay configuration, which is immutable.\n     * @return {?}\n     */\n    OverlayRef.prototype.getConfig = /**\n     * Gets the the current overlay configuration, which is immutable.\n     * @return {?}\n     */\n        function () {\n            return this._config;\n        };\n    /** Updates the position of the overlay based on the position strategy. */\n    /**\n     * Updates the position of the overlay based on the position strategy.\n     * @return {?}\n     */\n    OverlayRef.prototype.updatePosition = /**\n     * Updates the position of the overlay based on the position strategy.\n     * @return {?}\n     */\n        function () {\n            if (this._config.positionStrategy) {\n                this._config.positionStrategy.apply();\n            }\n        };\n    /** Update the size properties of the overlay. */\n    /**\n     * Update the size properties of the overlay.\n     * @param {?} sizeConfig\n     * @return {?}\n     */\n    OverlayRef.prototype.updateSize = /**\n     * Update the size properties of the overlay.\n     * @param {?} sizeConfig\n     * @return {?}\n     */\n        function (sizeConfig) {\n            this._config = __assign({}, this._config, sizeConfig);\n            this._updateElementSize();\n        };\n    /** Sets the LTR/RTL direction for the overlay. */\n    /**\n     * Sets the LTR/RTL direction for the overlay.\n     * @param {?} dir\n     * @return {?}\n     */\n    OverlayRef.prototype.setDirection = /**\n     * Sets the LTR/RTL direction for the overlay.\n     * @param {?} dir\n     * @return {?}\n     */\n        function (dir) {\n            this._config = __assign({}, this._config, { direction: dir });\n            this._updateElementDirection();\n        };\n    /**\n     * Updates the text direction of the overlay panel.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateElementDirection = /**\n     * Updates the text direction of the overlay panel.\n     * @return {?}\n     */\n        function () {\n            this._pane.setAttribute('dir', /** @type {?} */ ((this._config.direction)));\n        };\n    /**\n     * Updates the size of the overlay element based on the overlay config.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateElementSize = /**\n     * Updates the size of the overlay element based on the overlay config.\n     * @return {?}\n     */\n        function () {\n            if (this._config.width || this._config.width === 0) {\n                this._pane.style.width = formatCssUnit(this._config.width);\n            }\n            if (this._config.height || this._config.height === 0) {\n                this._pane.style.height = formatCssUnit(this._config.height);\n            }\n            if (this._config.minWidth || this._config.minWidth === 0) {\n                this._pane.style.minWidth = formatCssUnit(this._config.minWidth);\n            }\n            if (this._config.minHeight || this._config.minHeight === 0) {\n                this._pane.style.minHeight = formatCssUnit(this._config.minHeight);\n            }\n            if (this._config.maxWidth || this._config.maxWidth === 0) {\n                this._pane.style.maxWidth = formatCssUnit(this._config.maxWidth);\n            }\n            if (this._config.maxHeight || this._config.maxHeight === 0) {\n                this._pane.style.maxHeight = formatCssUnit(this._config.maxHeight);\n            }\n        };\n    /**\n     * Toggles the pointer events for the overlay pane element.\n     * @param {?} enablePointer\n     * @return {?}\n     */\n    OverlayRef.prototype._togglePointerEvents = /**\n     * Toggles the pointer events for the overlay pane element.\n     * @param {?} enablePointer\n     * @return {?}\n     */\n        function (enablePointer) {\n            this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';\n        };\n    /**\n     * Attaches a backdrop for this overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype._attachBackdrop = /**\n     * Attaches a backdrop for this overlay.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            var /** @type {?} */ showingClass = 'cdk-overlay-backdrop-showing';\n            this._backdropElement = this._document.createElement('div');\n            this._backdropElement.classList.add('cdk-overlay-backdrop');\n            if (this._config.backdropClass) {\n                this._backdropElement.classList.add(this._config.backdropClass);\n            } /** @type {?} */\n            ((\n            // Insert the backdrop before the pane in the DOM order,\n            // in order to handle stacked overlays properly.\n            this._pane.parentElement)).insertBefore(this._backdropElement, this._pane);\n            // Forward backdrop clicks such that the consumer of the overlay can perform whatever\n            // action desired when such a click occurs (usually closing the overlay).\n            this._backdropElement.addEventListener('click', function (event) { return _this._backdropClick.next(event); });\n            // Add class to fade-in the backdrop after one frame.\n            if (typeof requestAnimationFrame !== 'undefined') {\n                this._ngZone.runOutsideAngular(function () {\n                    requestAnimationFrame(function () {\n                        if (_this._backdropElement) {\n                            _this._backdropElement.classList.add(showingClass);\n                        }\n                    });\n                });\n            }\n            else {\n                this._backdropElement.classList.add(showingClass);\n            }\n        };\n    /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateStackingOrder = /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @return {?}\n     */\n        function () {\n            if (this._pane.nextSibling) {\n                /** @type {?} */ ((this._pane.parentNode)).appendChild(this._pane);\n            }\n        };\n    /** Detaches the backdrop (if any) associated with the overlay. */\n    /**\n     * Detaches the backdrop (if any) associated with the overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachBackdrop = /**\n     * Detaches the backdrop (if any) associated with the overlay.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            var /** @type {?} */ backdropToDetach = this._backdropElement;\n            if (backdropToDetach) {\n                var /** @type {?} */ finishDetach_1 = function () {\n                    // It may not be attached to anything in certain cases (e.g. unit tests).\n                    if (backdropToDetach && backdropToDetach.parentNode) {\n                        backdropToDetach.parentNode.removeChild(backdropToDetach);\n                    }\n                    // It is possible that a new portal has been attached to this overlay since we started\n                    // removing the backdrop. If that is the case, only clear the backdrop reference if it\n                    // is still the same instance that we started to remove.\n                    if (_this._backdropElement == backdropToDetach) {\n                        _this._backdropElement = null;\n                    }\n                };\n                backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');\n                if (this._config.backdropClass) {\n                    backdropToDetach.classList.remove(this._config.backdropClass);\n                }\n                backdropToDetach.addEventListener('transitionend', finishDetach_1);\n                // If the backdrop doesn't have a transition, the `transitionend` event won't fire.\n                // In this case we make it unclickable and we try to remove it after a delay.\n                backdropToDetach.style.pointerEvents = 'none';\n                // Run this outside the Angular zone because there's nothing that Angular cares about.\n                // If it were to run inside the Angular zone, every test that used Overlay would have to be\n                // either async or fakeAsync.\n                this._ngZone.runOutsideAngular(function () {\n                    setTimeout(finishDetach_1, 500);\n                });\n            }\n        };\n    return OverlayRef;\n}());\n/**\n * @param {?} value\n * @return {?}\n */\nfunction formatCssUnit(value) {\n    return typeof value === 'string' ? /** @type {?} */ (value) : value + \"px\";\n}\n/**\n * Size properties for an overlay.\n * @record\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nvar ConnectedPositionStrategy = /*@__PURE__*/ (function () {\n    function ConnectedPositionStrategy(originPos, overlayPos, _connectedTo, _viewportRuler, _document) {\n        this._connectedTo = _connectedTo;\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n        /**\n         * Layout direction of the position strategy.\n         */\n        this._dir = 'ltr';\n        /**\n         * The offset in pixels for the overlay connection point on the x-axis\n         */\n        this._offsetX = 0;\n        /**\n         * The offset in pixels for the overlay connection point on the y-axis\n         */\n        this._offsetY = 0;\n        /**\n         * The Scrollable containers used to check scrollable view properties on position change.\n         */\n        this.scrollables = [];\n        /**\n         * Subscription to viewport resize events.\n         */\n        this._resizeSubscription = Subscription.EMPTY;\n        /**\n         * Ordered list of preferred positions, from most to least desirable.\n         */\n        this._preferredPositions = [];\n        /**\n         * Whether the position strategy is applied currently.\n         */\n        this._applied = false;\n        /**\n         * Whether the overlay position is locked.\n         */\n        this._positionLocked = false;\n        this._onPositionChange = new Subject();\n        this._origin = this._connectedTo.nativeElement;\n        this.withFallbackPosition(originPos, overlayPos);\n    }\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"_isRtl\", {\n        /** Whether the we're dealing with an RTL context */\n        get: /**\n         * Whether the we're dealing with an RTL context\n         * @return {?}\n         */ function () {\n            return this._dir === 'rtl';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"onPositionChange\", {\n        /** Emits an event when the connection point changes. */\n        get: /**\n         * Emits an event when the connection point changes.\n         * @return {?}\n         */ function () {\n            return this._onPositionChange.asObservable();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"positions\", {\n        /** Ordered list of preferred positions, from most to least desirable. */\n        get: /**\n         * Ordered list of preferred positions, from most to least desirable.\n         * @return {?}\n         */ function () {\n            return this._preferredPositions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Attach this position strategy to an overlay. */\n    /**\n     * Attach this position strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.attach = /**\n     * Attach this position strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n        function (overlayRef) {\n            var _this = this;\n            this._pane = overlayRef.overlayElement;\n            this._resizeSubscription.unsubscribe();\n            this._resizeSubscription = this._viewportRuler.change().subscribe(function () { return _this.apply(); });\n        };\n    /** Disposes all resources used by the position strategy. */\n    /**\n     * Disposes all resources used by the position strategy.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.dispose = /**\n     * Disposes all resources used by the position strategy.\n     * @return {?}\n     */\n        function () {\n            this._applied = false;\n            this._resizeSubscription.unsubscribe();\n            this._onPositionChange.complete();\n        };\n    /** @docs-private */\n    /**\n     * \\@docs-private\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.detach = /**\n     * \\@docs-private\n     * @return {?}\n     */\n        function () {\n            this._applied = false;\n            this._resizeSubscription.unsubscribe();\n        };\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * @docs-private\n     */\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * \\@docs-private\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.apply = /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * \\@docs-private\n     * @return {?}\n     */\n        function () {\n            // If the position has been applied already (e.g. when the overlay was opened) and the\n            // consumer opted into locking in the position, re-use the  old position, in order to\n            // prevent the overlay from jumping around.\n            if (this._applied && this._positionLocked && this._lastConnectedPosition) {\n                this.recalculateLastPosition();\n                return;\n            }\n            this._applied = true;\n            // We need the bounding rects for the origin and the overlay to determine how to position\n            // the overlay relative to the origin.\n            var /** @type {?} */ element = this._pane;\n            var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n            var /** @type {?} */ overlayRect = element.getBoundingClientRect();\n            // We use the viewport size to determine whether a position would go off-screen.\n            var /** @type {?} */ viewportSize = this._viewportRuler.getViewportSize();\n            // Fallback point if none of the fallbacks fit into the viewport.\n            var /** @type {?} */ fallbackPoint;\n            var /** @type {?} */ fallbackPosition;\n            // We want to place the overlay in the first of the preferred positions such that the\n            // overlay fits on-screen.\n            for (var _i = 0, _a = this._preferredPositions; _i < _a.length; _i++) {\n                var pos = _a[_i];\n                // Get the (x, y) point of connection on the origin, and then use that to get the\n                // (top, left) coordinate for the overlay at `pos`.\n                var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, pos);\n                var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportSize, pos);\n                // If the overlay in the calculated position fits on-screen, put it there and we're done.\n                if (overlayPoint.fitsInViewport) {\n                    this._setElementPosition(element, overlayRect, overlayPoint, pos);\n                    // Save the last connected position in case the position needs to be re-calculated.\n                    this._lastConnectedPosition = pos;\n                    return;\n                }\n                else if (!fallbackPoint || fallbackPoint.visibleArea < overlayPoint.visibleArea) {\n                    fallbackPoint = overlayPoint;\n                    fallbackPosition = pos;\n                }\n            }\n            // If none of the preferred positions were in the viewport, take the one\n            // with the largest visible area.\n            this._setElementPosition(element, overlayRect, /** @type {?} */ ((fallbackPoint)), /** @type {?} */ ((fallbackPosition)));\n        };\n    /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     */\n    /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.recalculateLastPosition = /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     * @return {?}\n     */\n        function () {\n            // If the overlay has never been positioned before, do nothing.\n            if (!this._lastConnectedPosition) {\n                return;\n            }\n            var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n            var /** @type {?} */ overlayRect = this._pane.getBoundingClientRect();\n            var /** @type {?} */ viewportSize = this._viewportRuler.getViewportSize();\n            var /** @type {?} */ lastPosition = this._lastConnectedPosition || this._preferredPositions[0];\n            var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, lastPosition);\n            var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportSize, lastPosition);\n            this._setElementPosition(this._pane, overlayRect, overlayPoint, lastPosition);\n        };\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     */\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     * @param {?} scrollables\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withScrollableContainers = /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     * @param {?} scrollables\n     * @return {?}\n     */\n        function (scrollables) {\n            this.scrollables = scrollables;\n        };\n    /**\n     * Adds a new preferred fallback position.\n     * @param originPos\n     * @param overlayPos\n     */\n    /**\n     * Adds a new preferred fallback position.\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @param {?=} offsetX\n     * @param {?=} offsetY\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withFallbackPosition = /**\n     * Adds a new preferred fallback position.\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @param {?=} offsetX\n     * @param {?=} offsetY\n     * @return {?}\n     */\n        function (originPos, overlayPos, offsetX, offsetY) {\n            var /** @type {?} */ position = new ConnectionPositionPair(originPos, overlayPos, offsetX, offsetY);\n            this._preferredPositions.push(position);\n            return this;\n        };\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param dir New layout direction.\n     */\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param {?} dir New layout direction.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withDirection = /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param {?} dir New layout direction.\n     * @return {?}\n     */\n        function (dir) {\n            this._dir = dir;\n            return this;\n        };\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param offset New offset in the X axis.\n     */\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param {?} offset New offset in the X axis.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withOffsetX = /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param {?} offset New offset in the X axis.\n     * @return {?}\n     */\n        function (offset) {\n            this._offsetX = offset;\n            return this;\n        };\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param  offset New offset in the Y axis.\n     */\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param {?} offset New offset in the Y axis.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withOffsetY = /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param {?} offset New offset in the Y axis.\n     * @return {?}\n     */\n        function (offset) {\n            this._offsetY = offset;\n            return this;\n        };\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param isLocked Whether the overlay should locked in.\n     */\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param {?} isLocked Whether the overlay should locked in.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withLockedPosition = /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param {?} isLocked Whether the overlay should locked in.\n     * @return {?}\n     */\n        function (isLocked) {\n            this._positionLocked = isLocked;\n            return this;\n        };\n    /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param positions Position pairs to be set on the strategy.\n     */\n    /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param {?} positions Position pairs to be set on the strategy.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withPositions = /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param {?} positions Position pairs to be set on the strategy.\n     * @return {?}\n     */\n        function (positions) {\n            this._preferredPositions = positions.slice();\n            return this;\n        };\n    /**\n     * Sets the origin element, relative to which to position the overlay.\n     * @param origin Reference to the new origin element.\n     */\n    /**\n     * Sets the origin element, relative to which to position the overlay.\n     * @param {?} origin Reference to the new origin element.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.setOrigin = /**\n     * Sets the origin element, relative to which to position the overlay.\n     * @param {?} origin Reference to the new origin element.\n     * @return {?}\n     */\n        function (origin) {\n            this._origin = origin.nativeElement;\n            return this;\n        };\n    /**\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getStartX = /**\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n        function (rect) {\n            return this._isRtl ? rect.right : rect.left;\n        };\n    /**\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getEndX = /**\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n        function (rect) {\n            return this._isRtl ? rect.left : rect.right;\n        };\n    /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     * @param {?} originRect\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getOriginConnectionPoint = /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     * @param {?} originRect\n     * @param {?} pos\n     * @return {?}\n     */\n        function (originRect, pos) {\n            var /** @type {?} */ originStartX = this._getStartX(originRect);\n            var /** @type {?} */ originEndX = this._getEndX(originRect);\n            var /** @type {?} */ x;\n            if (pos.originX == 'center') {\n                x = originStartX + (originRect.width / 2);\n            }\n            else {\n                x = pos.originX == 'start' ? originStartX : originEndX;\n            }\n            var /** @type {?} */ y;\n            if (pos.originY == 'center') {\n                y = originRect.top + (originRect.height / 2);\n            }\n            else {\n                y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n            }\n            return { x: x, y: y };\n        };\n    /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected, as well as how much of the element\n     * would be inside the viewport at that position.\n     * @param {?} originPoint\n     * @param {?} overlayRect\n     * @param {?} viewportSize\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getOverlayPoint = /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected, as well as how much of the element\n     * would be inside the viewport at that position.\n     * @param {?} originPoint\n     * @param {?} overlayRect\n     * @param {?} viewportSize\n     * @param {?} pos\n     * @return {?}\n     */\n        function (originPoint, overlayRect, viewportSize, pos) {\n            // Calculate the (overlayStartX, overlayStartY), the start of the potential overlay position\n            // relative to the origin point.\n            var /** @type {?} */ overlayStartX;\n            if (pos.overlayX == 'center') {\n                overlayStartX = -overlayRect.width / 2;\n            }\n            else if (pos.overlayX === 'start') {\n                overlayStartX = this._isRtl ? -overlayRect.width : 0;\n            }\n            else {\n                overlayStartX = this._isRtl ? 0 : -overlayRect.width;\n            }\n            var /** @type {?} */ overlayStartY;\n            if (pos.overlayY == 'center') {\n                overlayStartY = -overlayRect.height / 2;\n            }\n            else {\n                overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n            }\n            // The (x, y) offsets of the overlay based on the current position.\n            var /** @type {?} */ offsetX = typeof pos.offsetX === 'undefined' ? this._offsetX : pos.offsetX;\n            var /** @type {?} */ offsetY = typeof pos.offsetY === 'undefined' ? this._offsetY : pos.offsetY;\n            // The (x, y) coordinates of the overlay.\n            var /** @type {?} */ x = originPoint.x + overlayStartX + offsetX;\n            var /** @type {?} */ y = originPoint.y + overlayStartY + offsetY;\n            // How much the overlay would overflow at this position, on each side.\n            var /** @type {?} */ leftOverflow = 0 - x;\n            var /** @type {?} */ rightOverflow = (x + overlayRect.width) - viewportSize.width;\n            var /** @type {?} */ topOverflow = 0 - y;\n            var /** @type {?} */ bottomOverflow = (y + overlayRect.height) - viewportSize.height;\n            // Visible parts of the element on each axis.\n            var /** @type {?} */ visibleWidth = this._subtractOverflows(overlayRect.width, leftOverflow, rightOverflow);\n            var /** @type {?} */ visibleHeight = this._subtractOverflows(overlayRect.height, topOverflow, bottomOverflow);\n            // The area of the element that's within the viewport.\n            var /** @type {?} */ visibleArea = visibleWidth * visibleHeight;\n            var /** @type {?} */ fitsInViewport = (overlayRect.width * overlayRect.height) === visibleArea;\n            return { x: x, y: y, fitsInViewport: fitsInViewport, visibleArea: visibleArea };\n        };\n    /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     * @param {?} overlay\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getScrollVisibility = /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     * @param {?} overlay\n     * @return {?}\n     */\n        function (overlay) {\n            var /** @type {?} */ originBounds = this._origin.getBoundingClientRect();\n            var /** @type {?} */ overlayBounds = overlay.getBoundingClientRect();\n            var /** @type {?} */ scrollContainerBounds = this.scrollables.map(function (s) { return s.getElementRef().nativeElement.getBoundingClientRect(); });\n            return {\n                isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\n                isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\n                isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\n                isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),\n            };\n        };\n    /**\n     * Physically positions the overlay element to the given coordinate.\n     * @param {?} element\n     * @param {?} overlayRect\n     * @param {?} overlayPoint\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._setElementPosition = /**\n     * Physically positions the overlay element to the given coordinate.\n     * @param {?} element\n     * @param {?} overlayRect\n     * @param {?} overlayPoint\n     * @param {?} pos\n     * @return {?}\n     */\n        function (element, overlayRect, overlayPoint, pos) {\n            // We want to set either `top` or `bottom` based on whether the overlay wants to appear above\n            // or below the origin and the direction in which the element will expand.\n            var /** @type {?} */ verticalStyleProperty = pos.overlayY === 'bottom' ? 'bottom' : 'top';\n            // When using `bottom`, we adjust the y position such that it is the distance\n            // from the bottom of the viewport rather than the top.\n            var /** @type {?} */ y = verticalStyleProperty === 'top' ?\n                overlayPoint.y :\n                this._document.documentElement.clientHeight - (overlayPoint.y + overlayRect.height);\n            // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n            // or \"after\" the origin, which determines the direction in which the element will expand.\n            // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n            // page is in RTL or LTR.\n            var /** @type {?} */ horizontalStyleProperty;\n            if (this._dir === 'rtl') {\n                horizontalStyleProperty = pos.overlayX === 'end' ? 'left' : 'right';\n            }\n            else {\n                horizontalStyleProperty = pos.overlayX === 'end' ? 'right' : 'left';\n            }\n            // When we're setting `right`, we adjust the x position such that it is the distance\n            // from the right edge of the viewport rather than the left edge.\n            var /** @type {?} */ x = horizontalStyleProperty === 'left' ?\n                overlayPoint.x :\n                this._document.documentElement.clientWidth - (overlayPoint.x + overlayRect.width);\n            // Reset any existing styles. This is necessary in case the preferred position has\n            // changed since the last `apply`.\n            ['top', 'bottom', 'left', 'right'].forEach(function (p) { return element.style[p] = null; });\n            element.style[verticalStyleProperty] = y + \"px\";\n            element.style[horizontalStyleProperty] = x + \"px\";\n            // Notify that the position has been changed along with its change properties.\n            var /** @type {?} */ scrollableViewProperties = this._getScrollVisibility(element);\n            var /** @type {?} */ positionChange = new ConnectedOverlayPositionChange(pos, scrollableViewProperties);\n            this._onPositionChange.next(positionChange);\n        };\n    /**\n     * Subtracts the amount that an element is overflowing on an axis from it's length.\n     * @param {?} length\n     * @param {...?} overflows\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._subtractOverflows = /**\n     * Subtracts the amount that an element is overflowing on an axis from it's length.\n     * @param {?} length\n     * @param {...?} overflows\n     * @return {?}\n     */\n        function (length) {\n            var overflows = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                overflows[_i - 1] = arguments[_i];\n            }\n            return overflows.reduce(function (currentValue, currentOverflow) {\n                return currentValue - Math.max(currentOverflow, 0);\n            }, length);\n        };\n    return ConnectedPositionStrategy;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * explicit position relative to the browser's viewport. We use flexbox, instead of\n * transforms, in order to avoid issues with subpixel rendering which can cause the\n * element to become blurry.\n */\nvar GlobalPositionStrategy = /*@__PURE__*/ (function () {\n    function GlobalPositionStrategy(_document) {\n        this._document = _document;\n        this._cssPosition = 'static';\n        this._topOffset = '';\n        this._bottomOffset = '';\n        this._leftOffset = '';\n        this._rightOffset = '';\n        this._alignItems = '';\n        this._justifyContent = '';\n        this._width = '';\n        this._height = '';\n        /**\n         * A lazily-created wrapper for the overlay element that is used as a flex container.\n         */\n        this._wrapper = null;\n    }\n    /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.attach = /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n        function (overlayRef) {\n            var /** @type {?} */ config = overlayRef.getConfig();\n            this._overlayRef = overlayRef;\n            if (this._width && !config.width) {\n                overlayRef.updateSize({ width: this._width });\n            }\n            if (this._height && !config.height) {\n                overlayRef.updateSize({ height: this._height });\n            }\n        };\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param value New top offset.\n     */\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New top offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.top = /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New top offset.\n     * @return {?}\n     */\n        function (value) {\n            if (value === void 0) {\n                value = '';\n            }\n            this._bottomOffset = '';\n            this._topOffset = value;\n            this._alignItems = 'flex-start';\n            return this;\n        };\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param value New left offset.\n     */\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New left offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.left = /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New left offset.\n     * @return {?}\n     */\n        function (value) {\n            if (value === void 0) {\n                value = '';\n            }\n            this._rightOffset = '';\n            this._leftOffset = value;\n            this._justifyContent = 'flex-start';\n            return this;\n        };\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param value New bottom offset.\n     */\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New bottom offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.bottom = /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New bottom offset.\n     * @return {?}\n     */\n        function (value) {\n            if (value === void 0) {\n                value = '';\n            }\n            this._topOffset = '';\n            this._bottomOffset = value;\n            this._alignItems = 'flex-end';\n            return this;\n        };\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param value New right offset.\n     */\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New right offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.right = /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New right offset.\n     * @return {?}\n     */\n        function (value) {\n            if (value === void 0) {\n                value = '';\n            }\n            this._leftOffset = '';\n            this._rightOffset = value;\n            this._justifyContent = 'flex-end';\n            return this;\n        };\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param value New width for the overlay\n     * @deprecated Pass the `width` through the `OverlayConfig`.\n     * @deletion-target 7.0.0\n     */\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @deprecated Pass the `width` through the `OverlayConfig`.\n     * \\@deletion-target 7.0.0\n     * @param {?=} value New width for the overlay\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.width = /**\n     * Sets the overlay width and clears any previously set width.\n     * @deprecated Pass the `width` through the `OverlayConfig`.\n     * \\@deletion-target 7.0.0\n     * @param {?=} value New width for the overlay\n     * @return {?}\n     */\n        function (value) {\n            if (value === void 0) {\n                value = '';\n            }\n            if (this._overlayRef) {\n                this._overlayRef.updateSize({ width: value });\n            }\n            else {\n                this._width = value;\n            }\n            return this;\n        };\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param value New height for the overlay\n     * @deprecated Pass the `height` through the `OverlayConfig`.\n     * @deletion-target 7.0.0\n     */\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @deprecated Pass the `height` through the `OverlayConfig`.\n     * \\@deletion-target 7.0.0\n     * @param {?=} value New height for the overlay\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.height = /**\n     * Sets the overlay height and clears any previously set height.\n     * @deprecated Pass the `height` through the `OverlayConfig`.\n     * \\@deletion-target 7.0.0\n     * @param {?=} value New height for the overlay\n     * @return {?}\n     */\n        function (value) {\n            if (value === void 0) {\n                value = '';\n            }\n            if (this._overlayRef) {\n                this._overlayRef.updateSize({ height: value });\n            }\n            else {\n                this._height = value;\n            }\n            return this;\n        };\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param offset Overlay offset from the horizontal center.\n     */\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param {?=} offset Overlay offset from the horizontal center.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.centerHorizontally = /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param {?=} offset Overlay offset from the horizontal center.\n     * @return {?}\n     */\n        function (offset) {\n            if (offset === void 0) {\n                offset = '';\n            }\n            this.left(offset);\n            this._justifyContent = 'center';\n            return this;\n        };\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param offset Overlay offset from the vertical center.\n     */\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param {?=} offset Overlay offset from the vertical center.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.centerVertically = /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param {?=} offset Overlay offset from the vertical center.\n     * @return {?}\n     */\n        function (offset) {\n            if (offset === void 0) {\n                offset = '';\n            }\n            this.top(offset);\n            this._alignItems = 'center';\n            return this;\n        };\n    /**\n     * Apply the position to the element.\n     * @docs-private\n     *\n     * @returns Resolved when the styles have been applied.\n     */\n    /**\n     * Apply the position to the element.\n     * \\@docs-private\n     *\n     * @return {?} Resolved when the styles have been applied.\n     */\n    GlobalPositionStrategy.prototype.apply = /**\n     * Apply the position to the element.\n     * \\@docs-private\n     *\n     * @return {?} Resolved when the styles have been applied.\n     */\n        function () {\n            // Since the overlay ref applies the strategy asynchronously, it could\n            // have been disposed before it ends up being applied. If that is the\n            // case, we shouldn't do anything.\n            if (!this._overlayRef.hasAttached()) {\n                return;\n            }\n            var /** @type {?} */ element = this._overlayRef.overlayElement;\n            if (!this._wrapper && element.parentNode) {\n                this._wrapper = this._document.createElement('div'); /** @type {?} */\n                ((this._wrapper)).classList.add('cdk-global-overlay-wrapper');\n                element.parentNode.insertBefore(/** @type {?} */ ((this._wrapper)), element); /** @type {?} */\n                ((this._wrapper)).appendChild(element);\n            }\n            var /** @type {?} */ styles = element.style;\n            var /** @type {?} */ parentStyles = ((element.parentNode)).style;\n            var /** @type {?} */ config = this._overlayRef.getConfig();\n            styles.position = this._cssPosition;\n            styles.marginLeft = config.width === '100%' ? '0' : this._leftOffset;\n            styles.marginTop = config.height === '100%' ? '0' : this._topOffset;\n            styles.marginBottom = this._bottomOffset;\n            styles.marginRight = this._rightOffset;\n            parentStyles.justifyContent = config.width === '100%' ? 'flex-start' : this._justifyContent;\n            parentStyles.alignItems = config.height === '100%' ? 'flex-start' : this._alignItems;\n        };\n    /** Removes the wrapper element from the DOM. */\n    /**\n     * Removes the wrapper element from the DOM.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.dispose = /**\n     * Removes the wrapper element from the DOM.\n     * @return {?}\n     */\n        function () {\n            if (this._wrapper && this._wrapper.parentNode) {\n                this._wrapper.parentNode.removeChild(this._wrapper);\n                this._wrapper = null;\n            }\n        };\n    return GlobalPositionStrategy;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Builder for overlay position strategy.\n */\nvar OverlayPositionBuilder = /*@__PURE__*/ (function () {\n    function OverlayPositionBuilder(_viewportRuler, _document) {\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n    }\n    /**\n     * Creates a global position strategy.\n     */\n    /**\n     * Creates a global position strategy.\n     * @return {?}\n     */\n    OverlayPositionBuilder.prototype.global = /**\n     * Creates a global position strategy.\n     * @return {?}\n     */\n        function () {\n            return new GlobalPositionStrategy(this._document);\n        };\n    /**\n     * Creates a relative position strategy.\n     * @param elementRef\n     * @param originPos\n     * @param overlayPos\n     */\n    /**\n     * Creates a relative position strategy.\n     * @param {?} elementRef\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n    OverlayPositionBuilder.prototype.connectedTo = /**\n     * Creates a relative position strategy.\n     * @param {?} elementRef\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n        function (elementRef, originPos, overlayPos) {\n            return new ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler, this._document);\n        };\n    return OverlayPositionBuilder;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Service for dispatching keyboard events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nvar OverlayKeyboardDispatcher = /*@__PURE__*/ (function () {\n    function OverlayKeyboardDispatcher(_document) {\n        this._document = _document;\n        /**\n         * Currently attached overlays in the order they were attached.\n         */\n        this._attachedOverlays = [];\n    }\n    /**\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this._unsubscribeFromKeydownEvents();\n        };\n    /** Add a new overlay to the list of attached overlay refs. */\n    /**\n     * Add a new overlay to the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.add = /**\n     * Add a new overlay to the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n        function (overlayRef) {\n            // Lazily start dispatcher once first overlay is added\n            if (!this._keydownEventSubscription) {\n                this._subscribeToKeydownEvents();\n            }\n            this._attachedOverlays.push(overlayRef);\n        };\n    /** Remove an overlay from the list of attached overlay refs. */\n    /**\n     * Remove an overlay from the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.remove = /**\n     * Remove an overlay from the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n        function (overlayRef) {\n            var /** @type {?} */ index = this._attachedOverlays.indexOf(overlayRef);\n            if (index > -1) {\n                this._attachedOverlays.splice(index, 1);\n            }\n            // Remove the global listener once there are no more overlays.\n            if (this._attachedOverlays.length === 0) {\n                this._unsubscribeFromKeydownEvents();\n            }\n        };\n    /**\n     * Subscribe to keydown events that land on the body and dispatch those\n     * events to the appropriate overlay.\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._subscribeToKeydownEvents = /**\n     * Subscribe to keydown events that land on the body and dispatch those\n     * events to the appropriate overlay.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            var /** @type {?} */ bodyKeydownEvents = fromEvent(this._document.body, 'keydown', true);\n            this._keydownEventSubscription = bodyKeydownEvents.pipe(filter(function () { return !!_this._attachedOverlays.length; })).subscribe(function (event) {\n                // Dispatch keydown event to the correct overlay.\n                // Dispatch keydown event to the correct overlay.\n                _this._selectOverlayFromEvent(event)._keydownEvents.next(event);\n            });\n        };\n    /**\n     * Removes the global keydown subscription.\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._unsubscribeFromKeydownEvents = /**\n     * Removes the global keydown subscription.\n     * @return {?}\n     */\n        function () {\n            if (this._keydownEventSubscription) {\n                this._keydownEventSubscription.unsubscribe();\n                this._keydownEventSubscription = null;\n            }\n        };\n    /**\n     * Select the appropriate overlay from a keydown event.\n     * @param {?} event\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._selectOverlayFromEvent = /**\n     * Select the appropriate overlay from a keydown event.\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            // Check if any overlays contain the event\n            var /** @type {?} */ targetedOverlay = this._attachedOverlays.find(function (overlay) {\n                return overlay.overlayElement === event.target ||\n                    overlay.overlayElement.contains(/** @type {?} */ (event.target));\n            });\n            // Use the overlay if it exists, otherwise choose the most recently attached one\n            return targetedOverlay || this._attachedOverlays[this._attachedOverlays.length - 1];\n        };\n    return OverlayKeyboardDispatcher;\n}());\n/**\n * \\@docs-private\n * @param {?} dispatcher\n * @param {?} _document\n * @return {?}\n */\nfunction OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY(dispatcher, _document) {\n    return dispatcher || new OverlayKeyboardDispatcher(_document);\n}\n/**\n * \\@docs-private\n */\nvar OVERLAY_KEYBOARD_DISPATCHER_PROVIDER = {\n    // If there is already an OverlayKeyboardDispatcher available, use that.\n    // Otherwise, provide a new one.\n    provide: OverlayKeyboardDispatcher,\n    deps: [\n        [/*@__PURE__*/ new Optional(), /*@__PURE__*/ new SkipSelf(), OverlayKeyboardDispatcher],\n        /** @type {?} */ (\n        // Coerce to `InjectionToken` so that the `deps` match the \"shape\"\n        // of the type expected by Angular\n        DOCUMENT)\n    ],\n    useFactory: OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Container inside which all overlays will render.\n */\nvar OverlayContainer = /*@__PURE__*/ (function () {\n    function OverlayContainer(_document) {\n        this._document = _document;\n    }\n    /**\n     * @return {?}\n     */\n    OverlayContainer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            if (this._containerElement && this._containerElement.parentNode) {\n                this._containerElement.parentNode.removeChild(this._containerElement);\n            }\n        };\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @returns the container element\n     */\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n    OverlayContainer.prototype.getContainerElement = /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n        function () {\n            if (!this._containerElement) {\n                this._createContainer();\n            }\n            return this._containerElement;\n        };\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     */\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @return {?}\n     */\n    OverlayContainer.prototype._createContainer = /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @return {?}\n     */\n        function () {\n            var /** @type {?} */ container = this._document.createElement('div');\n            container.classList.add('cdk-overlay-container');\n            this._document.body.appendChild(container);\n            this._containerElement = container;\n        };\n    return OverlayContainer;\n}());\n/**\n * \\@docs-private\n * @param {?} parentContainer\n * @param {?} _document\n * @return {?}\n */\nfunction OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer, _document) {\n    return parentContainer || new OverlayContainer(_document);\n}\n/**\n * \\@docs-private\n */\nvar OVERLAY_CONTAINER_PROVIDER = {\n    // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.\n    provide: OverlayContainer,\n    deps: [\n        [/*@__PURE__*/ new Optional(), /*@__PURE__*/ new SkipSelf(), OverlayContainer],\n        /** @type {?} */ (DOCUMENT // We need to use the InjectionToken somewhere to keep TS happy\n        ) // We need to use the InjectionToken somewhere to keep TS happy\n    ],\n    useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Next overlay unique ID.\n */\nvar nextUniqueId = 0;\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.\n */\nvar Overlay = /*@__PURE__*/ (function () {\n    function Overlay(scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _appRef, _injector, _ngZone, _document) {\n        this.scrollStrategies = scrollStrategies;\n        this._overlayContainer = _overlayContainer;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._positionBuilder = _positionBuilder;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._appRef = _appRef;\n        this._injector = _injector;\n        this._ngZone = _ngZone;\n        this._document = _document;\n    }\n    /**\n     * Creates an overlay.\n     * @param config Configuration applied to the overlay.\n     * @returns Reference to the created overlay.\n     */\n    /**\n     * Creates an overlay.\n     * @param {?=} config Configuration applied to the overlay.\n     * @return {?} Reference to the created overlay.\n     */\n    Overlay.prototype.create = /**\n     * Creates an overlay.\n     * @param {?=} config Configuration applied to the overlay.\n     * @return {?} Reference to the created overlay.\n     */\n        function (config) {\n            var /** @type {?} */ pane = this._createPaneElement();\n            var /** @type {?} */ portalOutlet = this._createPortalOutlet(pane);\n            return new OverlayRef(portalOutlet, pane, new OverlayConfig(config), this._ngZone, this._keyboardDispatcher, this._document);\n        };\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @returns An overlay position builder.\n     */\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @return {?} An overlay position builder.\n     */\n    Overlay.prototype.position = /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @return {?} An overlay position builder.\n     */\n        function () {\n            return this._positionBuilder;\n        };\n    /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @return {?} Newly-created pane element\n     */\n    Overlay.prototype._createPaneElement = /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @return {?} Newly-created pane element\n     */\n        function () {\n            var /** @type {?} */ pane = this._document.createElement('div');\n            pane.id = \"cdk-overlay-\" + nextUniqueId++;\n            pane.classList.add('cdk-overlay-pane');\n            this._overlayContainer.getContainerElement().appendChild(pane);\n            return pane;\n        };\n    /**\n     * Create a DomPortalOutlet into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal outlet.\n     * @return {?} A portal outlet for the given DOM element.\n     */\n    Overlay.prototype._createPortalOutlet = /**\n     * Create a DomPortalOutlet into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal outlet.\n     * @return {?} A portal outlet for the given DOM element.\n     */\n        function (pane) {\n            return new DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector);\n        };\n    return Overlay;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Default set of positions for the overlay. Follows the behavior of a dropdown.\n */\nvar defaultPositionList = [\n    /*@__PURE__*/ new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),\n    /*@__PURE__*/ new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),\n    /*@__PURE__*/ new ConnectionPositionPair({ originX: 'end', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' }),\n    /*@__PURE__*/ new ConnectionPositionPair({ originX: 'end', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' }),\n];\n/**\n * Injection token that determines the scroll handling while the connected overlay is open.\n */\nvar CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = /*@__PURE__*/ new InjectionToken('cdk-connected-overlay-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    return function () { return overlay.scrollStrategies.reposition(); };\n}\n/**\n * \\@docs-private\n */\nvar CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {\n    provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n/**\n * Directive applied to an element to make it usable as an origin for an Overlay using a\n * ConnectedPositionStrategy.\n */\nvar CdkOverlayOrigin = /*@__PURE__*/ (function () {\n    function CdkOverlayOrigin(elementRef) {\n        this.elementRef = elementRef;\n    }\n    return CdkOverlayOrigin;\n}());\n/**\n * Directive to facilitate declarative creation of an Overlay using a ConnectedPositionStrategy.\n */\nvar CdkConnectedOverlay = /*@__PURE__*/ (function () {\n    // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.\n    function CdkConnectedOverlay(_overlay, templateRef, viewContainerRef, _scrollStrategy, _dir) {\n        this._overlay = _overlay;\n        this._scrollStrategy = _scrollStrategy;\n        this._dir = _dir;\n        this._hasBackdrop = false;\n        this._lockPosition = false;\n        this._backdropSubscription = Subscription.EMPTY;\n        this._offsetX = 0;\n        this._offsetY = 0;\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = this._scrollStrategy();\n        /**\n         * Whether the overlay is open.\n         */\n        this.open = false;\n        /**\n         * Event emitted when the backdrop is clicked.\n         */\n        this.backdropClick = new EventEmitter();\n        /**\n         * Event emitted when the position has changed.\n         */\n        this.positionChange = new EventEmitter();\n        /**\n         * Event emitted when the overlay has been attached.\n         */\n        this.attach = new EventEmitter();\n        /**\n         * Event emitted when the overlay has been detached.\n         */\n        this.detach = new EventEmitter();\n        this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);\n    }\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"offsetX\", {\n        get: /**\n         * The offset in pixels for the overlay connection point on the x-axis\n         * @return {?}\n         */ function () { return this._offsetX; },\n        set: /**\n         * @param {?} offsetX\n         * @return {?}\n         */ function (offsetX) {\n            this._offsetX = offsetX;\n            if (this._position) {\n                this._position.withOffsetX(offsetX);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"offsetY\", {\n        get: /**\n         * The offset in pixels for the overlay connection point on the y-axis\n         * @return {?}\n         */ function () { return this._offsetY; },\n        set: /**\n         * @param {?} offsetY\n         * @return {?}\n         */ function (offsetY) {\n            this._offsetY = offsetY;\n            if (this._position) {\n                this._position.withOffsetY(offsetY);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"hasBackdrop\", {\n        get: /**\n         * Whether or not the overlay should attach a backdrop.\n         * @return {?}\n         */ function () { return this._hasBackdrop; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) { this._hasBackdrop = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"lockPosition\", {\n        get: /**\n         * Whether or not the overlay should be locked when scrolling.\n         * @return {?}\n         */ function () { return this._lockPosition; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) { this._lockPosition = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOrigin\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */ function () { return this.origin; },\n        set: /**\n         * @param {?} _origin\n         * @return {?}\n         */ function (_origin) { this.origin = _origin; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedPositions\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */ function () { return this.positions; },\n        set: /**\n         * @param {?} _positions\n         * @return {?}\n         */ function (_positions) { this.positions = _positions; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOffsetX\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */ function () { return this.offsetX; },\n        set: /**\n         * @param {?} _offsetX\n         * @return {?}\n         */ function (_offsetX) { this.offsetX = _offsetX; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOffsetY\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */ function () { return this.offsetY; },\n        set: /**\n         * @param {?} _offsetY\n         * @return {?}\n         */ function (_offsetY) { this.offsetY = _offsetY; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedWidth\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */ function () { return this.width; },\n        set: /**\n         * @param {?} _width\n         * @return {?}\n         */ function (_width) { this.width = _width; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedHeight\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */ function () { return this.height; },\n        set: /**\n         * @param {?} _height\n         * @return {?}\n         */ function (_height) { this.height = _height; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedMinWidth\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */ function () { return this.minWidth; },\n        set: /**\n         * @param {?} _minWidth\n         * @return {?}\n         */ function (_minWidth) { this.minWidth = _minWidth; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedMinHeight\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */ function () { return this.minHeight; },\n        set: /**\n         * @param {?} _minHeight\n         * @return {?}\n         */ function (_minHeight) { this.minHeight = _minHeight; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedBackdropClass\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */ function () { return this.backdropClass; },\n        set: /**\n         * @param {?} _backdropClass\n         * @return {?}\n         */ function (_backdropClass) { this.backdropClass = _backdropClass; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedScrollStrategy\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */ function () { return this.scrollStrategy; },\n        set: /**\n         * @param {?} _scrollStrategy\n         * @return {?}\n         */ function (_scrollStrategy) {\n            this.scrollStrategy = _scrollStrategy;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOpen\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */ function () { return this.open; },\n        set: /**\n         * @param {?} _open\n         * @return {?}\n         */ function (_open) { this.open = _open; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedHasBackdrop\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */ function () { return this.hasBackdrop; },\n        set: /**\n         * @param {?} _hasBackdrop\n         * @return {?}\n         */ function (_hasBackdrop) { this.hasBackdrop = _hasBackdrop; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"overlayRef\", {\n        /** The associated overlay reference. */\n        get: /**\n         * The associated overlay reference.\n         * @return {?}\n         */ function () {\n            return this._overlayRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"dir\", {\n        /** The element's layout direction. */\n        get: /**\n         * The element's layout direction.\n         * @return {?}\n         */ function () {\n            return this._dir ? this._dir.value : 'ltr';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this._destroyOverlay();\n        };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n        function (changes) {\n            if (this._position) {\n                if (changes['positions'] || changes['_deprecatedPositions']) {\n                    this._position.withPositions(this.positions);\n                }\n                if (changes['lockPosition']) {\n                    this._position.withLockedPosition(this.lockPosition);\n                }\n                if (changes['origin'] || changes['_deprecatedOrigin']) {\n                    this._position.setOrigin(this.origin.elementRef);\n                    if (this.open) {\n                        this._position.apply();\n                    }\n                }\n            }\n            if (changes['open'] || changes['_deprecatedOpen']) {\n                this.open ? this._attachOverlay() : this._detachOverlay();\n            }\n        };\n    /**\n     * Creates an overlay\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._createOverlay = /**\n     * Creates an overlay\n     * @return {?}\n     */\n        function () {\n            if (!this.positions || !this.positions.length) {\n                this.positions = defaultPositionList;\n            }\n            this._overlayRef = this._overlay.create(this._buildConfig());\n        };\n    /**\n     * Builds the overlay config based on the directive's inputs\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._buildConfig = /**\n     * Builds the overlay config based on the directive's inputs\n     * @return {?}\n     */\n        function () {\n            var /** @type {?} */ positionStrategy = this._position = this._createPositionStrategy();\n            var /** @type {?} */ overlayConfig = new OverlayConfig({\n                positionStrategy: positionStrategy,\n                scrollStrategy: this.scrollStrategy,\n                hasBackdrop: this.hasBackdrop\n            });\n            if (this.width || this.width === 0) {\n                overlayConfig.width = this.width;\n            }\n            if (this.height || this.height === 0) {\n                overlayConfig.height = this.height;\n            }\n            if (this.minWidth || this.minWidth === 0) {\n                overlayConfig.minWidth = this.minWidth;\n            }\n            if (this.minHeight || this.minHeight === 0) {\n                overlayConfig.minHeight = this.minHeight;\n            }\n            if (this.backdropClass) {\n                overlayConfig.backdropClass = this.backdropClass;\n            }\n            return overlayConfig;\n        };\n    /**\n     * Returns the position strategy of the overlay to be set on the overlay config\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._createPositionStrategy = /**\n     * Returns the position strategy of the overlay to be set on the overlay config\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            var /** @type {?} */ primaryPosition = this.positions[0];\n            var /** @type {?} */ originPoint = { originX: primaryPosition.originX, originY: primaryPosition.originY };\n            var /** @type {?} */ overlayPoint = { overlayX: primaryPosition.overlayX, overlayY: primaryPosition.overlayY };\n            var /** @type {?} */ strategy = this._overlay.position()\n                .connectedTo(this.origin.elementRef, originPoint, overlayPoint)\n                .withOffsetX(this.offsetX)\n                .withOffsetY(this.offsetY)\n                .withLockedPosition(this.lockPosition);\n            for (var /** @type {?} */ i = 1; i < this.positions.length; i++) {\n                strategy.withFallbackPosition({ originX: this.positions[i].originX, originY: this.positions[i].originY }, { overlayX: this.positions[i].overlayX, overlayY: this.positions[i].overlayY });\n            }\n            strategy.onPositionChange.subscribe(function (pos) { return _this.positionChange.emit(pos); });\n            return strategy;\n        };\n    /**\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._attachOverlay = /**\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (!this._overlayRef) {\n                this._createOverlay(); /** @type {?} */\n                ((this._overlayRef)).keydownEvents().subscribe(function (event) {\n                    if (event.keyCode === ESCAPE) {\n                        _this._detachOverlay();\n                    }\n                });\n            }\n            else {\n                // Update the overlay size, in case the directive's inputs have changed\n                this._overlayRef.updateSize({\n                    width: this.width,\n                    minWidth: this.minWidth,\n                    height: this.height,\n                    minHeight: this.minHeight,\n                });\n            }\n            this._position.withDirection(this.dir);\n            this._overlayRef.setDirection(this.dir);\n            if (!this._overlayRef.hasAttached()) {\n                this._overlayRef.attach(this._templatePortal);\n                this.attach.emit();\n            }\n            if (this.hasBackdrop) {\n                this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function (event) {\n                    _this.backdropClick.emit(event);\n                });\n            }\n        };\n    /**\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._detachOverlay = /**\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n        function () {\n            if (this._overlayRef) {\n                this._overlayRef.detach();\n                this.detach.emit();\n            }\n            this._backdropSubscription.unsubscribe();\n        };\n    /**\n     * Destroys the overlay created by this directive.\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._destroyOverlay = /**\n     * Destroys the overlay created by this directive.\n     * @return {?}\n     */\n        function () {\n            if (this._overlayRef) {\n                this._overlayRef.dispose();\n            }\n            this._backdropSubscription.unsubscribe();\n        };\n    return CdkConnectedOverlay;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar OVERLAY_PROVIDERS = [\n    Overlay,\n    OverlayPositionBuilder,\n    OVERLAY_KEYBOARD_DISPATCHER_PROVIDER,\n    VIEWPORT_RULER_PROVIDER,\n    OVERLAY_CONTAINER_PROVIDER,\n    CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,\n];\nvar OverlayModule = /*@__PURE__*/ (function () {\n    function OverlayModule() {\n    }\n    return OverlayModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Alternative to OverlayContainer that supports correct displaying of overlay elements in\n * Fullscreen mode\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen\n *\n * Should be provided in the root component.\n */\nvar FullscreenOverlayContainer = /*@__PURE__*/ (function (_super) {\n    __extends(FullscreenOverlayContainer, _super);\n    function FullscreenOverlayContainer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._createContainer = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            _super.prototype._createContainer.call(this);\n            this._adjustParentForFullscreenChange();\n            this._addFullscreenChangeListener(function () { return _this._adjustParentForFullscreenChange(); });\n        };\n    /**\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._adjustParentForFullscreenChange = /**\n     * @return {?}\n     */\n        function () {\n            if (!this._containerElement) {\n                return;\n            }\n            var /** @type {?} */ fullscreenElement = this.getFullscreenElement();\n            var /** @type {?} */ parent = fullscreenElement || document.body;\n            parent.appendChild(this._containerElement);\n        };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._addFullscreenChangeListener = /**\n     * @param {?} fn\n     * @return {?}\n     */\n        function (fn) {\n            if (document.fullscreenEnabled) {\n                document.addEventListener('fullscreenchange', fn);\n            }\n            else if (document.webkitFullscreenEnabled) {\n                document.addEventListener('webkitfullscreenchange', fn);\n            }\n            else if (((document)).mozFullScreenEnabled) {\n                document.addEventListener('mozfullscreenchange', fn);\n            }\n            else if (((document)).msFullscreenEnabled) {\n                document.addEventListener('MSFullscreenChange', fn);\n            }\n        };\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     */\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype.getFullscreenElement = /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     * @return {?}\n     */\n        function () {\n            return document.fullscreenElement ||\n                document.webkitFullscreenElement ||\n                ((document)).mozFullScreenElement ||\n                ((document)).msFullscreenElement ||\n                null;\n        };\n    return FullscreenOverlayContainer;\n}(OverlayContainer));\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { Overlay, OverlayContainer, CdkOverlayOrigin, CdkConnectedOverlay, FullscreenOverlayContainer, OverlayRef, ViewportRuler, OverlayKeyboardDispatcher, OverlayPositionBuilder, GlobalPositionStrategy, ConnectedPositionStrategy, VIEWPORT_RULER_PROVIDER, CdkConnectedOverlay as ConnectedOverlayDirective, CdkOverlayOrigin as OverlayOrigin, OverlayConfig, ConnectionPositionPair, ScrollingVisibility, ConnectedOverlayPositionChange, CdkScrollable, ScrollDispatcher, ScrollStrategyOptions, RepositionScrollStrategy, CloseScrollStrategy, NoopScrollStrategy, BlockScrollStrategy, OVERLAY_PROVIDERS, OverlayModule, OVERLAY_KEYBOARD_DISPATCHER_PROVIDER as ɵg, OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY as ɵf, OVERLAY_CONTAINER_PROVIDER as ɵb, OVERLAY_CONTAINER_PROVIDER_FACTORY as ɵa, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY as ɵc, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER as ɵe, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY as ɵd };\n//# sourceMappingURL=overlay.es5.js.map\n",null]}