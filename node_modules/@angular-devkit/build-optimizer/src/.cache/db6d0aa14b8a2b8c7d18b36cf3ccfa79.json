{"remainingRequest":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\xampp\\htdocs\\GroupReads\\node_modules\\rxjs\\_esm5\\operators\\debounceTime.js","dependencies":[{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\rxjs\\_esm5\\operators\\debounceTime.js","mtime":1524743248380},{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1524743208736},{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1524743165754}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { Subscriber } from '../Subscriber';\r\nimport { async } from '../scheduler/async';\r\n/**\r\n * Emits a value from the source Observable only after a particular time span\r\n * has passed without another source emission.\r\n *\r\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\r\n * recent value from each burst of emissions.</span>\r\n *\r\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\r\n *\r\n * `debounceTime` delays values emitted by the source Observable, but drops\r\n * previous pending delayed emissions if a new value arrives on the source\r\n * Observable. This operator keeps track of the most recent value from the\r\n * source Observable, and emits that only when `dueTime` enough time has passed\r\n * without any other value appearing on the source Observable. If a new value\r\n * appears before `dueTime` silence occurs, the previous value will be dropped\r\n * and will not be emitted on the output Observable.\r\n *\r\n * This is a rate-limiting operator, because it is impossible for more than one\r\n * value to be emitted in any time window of duration `dueTime`, but it is also\r\n * a delay-like operator since output emissions do not occur at the same time as\r\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\r\n * managing timers.\r\n *\r\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var result = clicks.debounceTime(1000);\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * @see {@link auditTime}\r\n * @see {@link debounce}\r\n * @see {@link delay}\r\n * @see {@link sampleTime}\r\n * @see {@link throttleTime}\r\n *\r\n * @param {number} dueTime The timeout duration in milliseconds (or the time\r\n * unit determined internally by the optional `scheduler`) for the window of\r\n * time required to wait for emission silence before emitting the most recent\r\n * source value.\r\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\r\n * managing the timers that handle the timeout for each value.\r\n * @return {Observable} An Observable that delays the emissions of the source\r\n * Observable by the specified `dueTime`, and may drop some values if they occur\r\n * too frequently.\r\n * @method debounceTime\r\n * @owner Observable\r\n */\r\nexport function debounceTime(dueTime, scheduler) {\r\n    if (scheduler === void 0) {\r\n        scheduler = async;\r\n    }\r\n    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };\r\n}\r\nvar DebounceTimeOperator = /*@__PURE__*/ (function () {\r\n    function DebounceTimeOperator(dueTime, scheduler) {\r\n        this.dueTime = dueTime;\r\n        this.scheduler = scheduler;\r\n    }\r\n    DebounceTimeOperator.prototype.call = function (subscriber, source) {\r\n        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\r\n    };\r\n    return DebounceTimeOperator;\r\n}());\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nvar DebounceTimeSubscriber = /*@__PURE__*/ (function (_super) {\r\n    __extends(DebounceTimeSubscriber, _super);\r\n    function DebounceTimeSubscriber(destination, dueTime, scheduler) {\r\n        _super.call(this, destination);\r\n        this.dueTime = dueTime;\r\n        this.scheduler = scheduler;\r\n        this.debouncedSubscription = null;\r\n        this.lastValue = null;\r\n        this.hasValue = false;\r\n    }\r\n    DebounceTimeSubscriber.prototype._next = function (value) {\r\n        this.clearDebounce();\r\n        this.lastValue = value;\r\n        this.hasValue = true;\r\n        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\r\n    };\r\n    DebounceTimeSubscriber.prototype._complete = function () {\r\n        this.debouncedNext();\r\n        this.destination.complete();\r\n    };\r\n    DebounceTimeSubscriber.prototype.debouncedNext = function () {\r\n        this.clearDebounce();\r\n        if (this.hasValue) {\r\n            this.destination.next(this.lastValue);\r\n            this.lastValue = null;\r\n            this.hasValue = false;\r\n        }\r\n    };\r\n    DebounceTimeSubscriber.prototype.clearDebounce = function () {\r\n        var debouncedSubscription = this.debouncedSubscription;\r\n        if (debouncedSubscription !== null) {\r\n            this.remove(debouncedSubscription);\r\n            debouncedSubscription.unsubscribe();\r\n            this.debouncedSubscription = null;\r\n        }\r\n    };\r\n    return DebounceTimeSubscriber;\r\n}(Subscriber));\r\nfunction dispatchNext(subscriber) {\r\n    subscriber.debouncedNext();\r\n}\r\n//# sourceMappingURL=debounceTime.js.map\r\n",null]}