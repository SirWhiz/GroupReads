{"remainingRequest":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\xampp\\htdocs\\GroupReads\\node_modules\\rxjs\\_esm5\\observable\\EmptyObservable.js","dependencies":[{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\rxjs\\_esm5\\observable\\EmptyObservable.js","mtime":1524743247961},{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1524743208736},{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1524743165754}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { Observable } from '../Observable';\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @extends {Ignored}\r\n * @hide true\r\n */\r\nexport var EmptyObservable = /*@__PURE__*/ (function (_super) {\r\n    __extends(EmptyObservable, _super);\r\n    function EmptyObservable(scheduler) {\r\n        _super.call(this);\r\n        this.scheduler = scheduler;\r\n    }\r\n    /**\r\n     * Creates an Observable that emits no items to the Observer and immediately\r\n     * emits a complete notification.\r\n     *\r\n     * <span class=\"informal\">Just emits 'complete', and nothing else.\r\n     * </span>\r\n     *\r\n     * <img src=\"./img/empty.png\" width=\"100%\">\r\n     *\r\n     * This static operator is useful for creating a simple Observable that only\r\n     * emits the complete notification. It can be used for composing with other\r\n     * Observables, such as in a {@link mergeMap}.\r\n     *\r\n     * @example <caption>Emit the number 7, then complete.</caption>\r\n     * var result = Rx.Observable.empty().startWith(7);\r\n     * result.subscribe(x => console.log(x));\r\n     *\r\n     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>\r\n     * var interval = Rx.Observable.interval(1000);\r\n     * var result = interval.mergeMap(x =>\r\n     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()\r\n     * );\r\n     * result.subscribe(x => console.log(x));\r\n     *\r\n     * // Results in the following to the console:\r\n     * // x is equal to the count on the interval eg(0,1,2,3,...)\r\n     * // x will occur every 1000ms\r\n     * // if x % 2 is equal to 1 print abc\r\n     * // if x % 2 is not equal to 1 nothing will be output\r\n     *\r\n     * @see {@link create}\r\n     * @see {@link never}\r\n     * @see {@link of}\r\n     * @see {@link throw}\r\n     *\r\n     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\r\n     * the emission of the complete notification.\r\n     * @return {Observable} An \"empty\" Observable: emits only the complete\r\n     * notification.\r\n     * @static true\r\n     * @name empty\r\n     * @owner Observable\r\n     */\r\n    EmptyObservable.create = function (scheduler) {\r\n        return new EmptyObservable(scheduler);\r\n    };\r\n    EmptyObservable.dispatch = function (arg) {\r\n        var subscriber = arg.subscriber;\r\n        subscriber.complete();\r\n    };\r\n    EmptyObservable.prototype._subscribe = function (subscriber) {\r\n        var scheduler = this.scheduler;\r\n        if (scheduler) {\r\n            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });\r\n        }\r\n        else {\r\n            subscriber.complete();\r\n        }\r\n    };\r\n    return EmptyObservable;\r\n}(Observable));\r\n//# sourceMappingURL=EmptyObservable.js.map\r\n",null]}