{"remainingRequest":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\xampp\\htdocs\\GroupReads\\node_modules\\rxjs\\_esm5\\Subscriber.js","dependencies":[{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\rxjs\\_esm5\\Subscriber.js","mtime":1524743247583},{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1524743208736},{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1524743165754}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { isFunction } from './util/isFunction';\r\nimport { Subscription } from './Subscription';\r\nimport { empty as emptyObserver } from './Observer';\r\nimport { rxSubscriber as rxSubscriberSymbol } from './symbol/rxSubscriber';\r\n/**\r\n * Implements the {@link Observer} interface and extends the\r\n * {@link Subscription} class. While the {@link Observer} is the public API for\r\n * consuming the values of an {@link Observable}, all Observers get converted to\r\n * a Subscriber, in order to provide Subscription-like capabilities such as\r\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\r\n * implementing operators, but it is rarely used as a public API.\r\n *\r\n * @class Subscriber<T>\r\n */\r\nexport var Subscriber = /*@__PURE__*/ (function (_super) {\r\n    __extends(Subscriber, _super);\r\n    /**\r\n     * @param {Observer|function(value: T): void} [destinationOrNext] A partially\r\n     * defined Observer or a `next` callback function.\r\n     * @param {function(e: ?any): void} [error] The `error` callback of an\r\n     * Observer.\r\n     * @param {function(): void} [complete] The `complete` callback of an\r\n     * Observer.\r\n     */\r\n    function Subscriber(destinationOrNext, error, complete) {\r\n        _super.call(this);\r\n        this.syncErrorValue = null;\r\n        this.syncErrorThrown = false;\r\n        this.syncErrorThrowable = false;\r\n        this.isStopped = false;\r\n        switch (arguments.length) {\r\n            case 0:\r\n                this.destination = emptyObserver;\r\n                break;\r\n            case 1:\r\n                if (!destinationOrNext) {\r\n                    this.destination = emptyObserver;\r\n                    break;\r\n                }\r\n                if (typeof destinationOrNext === 'object') {\r\n                    // HACK(benlesh): To resolve an issue where Node users may have multiple\r\n                    // copies of rxjs in their node_modules directory.\r\n                    if (isTrustedSubscriber(destinationOrNext)) {\r\n                        var trustedSubscriber = destinationOrNext[rxSubscriberSymbol]();\r\n                        this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable;\r\n                        this.destination = trustedSubscriber;\r\n                        trustedSubscriber.add(this);\r\n                    }\r\n                    else {\r\n                        this.syncErrorThrowable = true;\r\n                        this.destination = new SafeSubscriber(this, destinationOrNext);\r\n                    }\r\n                    break;\r\n                }\r\n            default:\r\n                this.syncErrorThrowable = true;\r\n                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\r\n                break;\r\n        }\r\n    }\r\n    Subscriber.prototype[rxSubscriberSymbol] = function () { return this; };\r\n    /**\r\n     * A static factory for a Subscriber, given a (potentially partial) definition\r\n     * of an Observer.\r\n     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\r\n     * @param {function(e: ?any): void} [error] The `error` callback of an\r\n     * Observer.\r\n     * @param {function(): void} [complete] The `complete` callback of an\r\n     * Observer.\r\n     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\r\n     * Observer represented by the given arguments.\r\n     */\r\n    Subscriber.create = function (next, error, complete) {\r\n        var subscriber = new Subscriber(next, error, complete);\r\n        subscriber.syncErrorThrowable = false;\r\n        return subscriber;\r\n    };\r\n    /**\r\n     * The {@link Observer} callback to receive notifications of type `next` from\r\n     * the Observable, with a value. The Observable may call this method 0 or more\r\n     * times.\r\n     * @param {T} [value] The `next` value.\r\n     * @return {void}\r\n     */\r\n    Subscriber.prototype.next = function (value) {\r\n        if (!this.isStopped) {\r\n            this._next(value);\r\n        }\r\n    };\r\n    /**\r\n     * The {@link Observer} callback to receive notifications of type `error` from\r\n     * the Observable, with an attached {@link Error}. Notifies the Observer that\r\n     * the Observable has experienced an error condition.\r\n     * @param {any} [err] The `error` exception.\r\n     * @return {void}\r\n     */\r\n    Subscriber.prototype.error = function (err) {\r\n        if (!this.isStopped) {\r\n            this.isStopped = true;\r\n            this._error(err);\r\n        }\r\n    };\r\n    /**\r\n     * The {@link Observer} callback to receive a valueless notification of type\r\n     * `complete` from the Observable. Notifies the Observer that the Observable\r\n     * has finished sending push-based notifications.\r\n     * @return {void}\r\n     */\r\n    Subscriber.prototype.complete = function () {\r\n        if (!this.isStopped) {\r\n            this.isStopped = true;\r\n            this._complete();\r\n        }\r\n    };\r\n    Subscriber.prototype.unsubscribe = function () {\r\n        if (this.closed) {\r\n            return;\r\n        }\r\n        this.isStopped = true;\r\n        _super.prototype.unsubscribe.call(this);\r\n    };\r\n    Subscriber.prototype._next = function (value) {\r\n        this.destination.next(value);\r\n    };\r\n    Subscriber.prototype._error = function (err) {\r\n        this.destination.error(err);\r\n        this.unsubscribe();\r\n    };\r\n    Subscriber.prototype._complete = function () {\r\n        this.destination.complete();\r\n        this.unsubscribe();\r\n    };\r\n    Subscriber.prototype._unsubscribeAndRecycle = function () {\r\n        var _a = this, _parent = _a._parent, _parents = _a._parents;\r\n        this._parent = null;\r\n        this._parents = null;\r\n        this.unsubscribe();\r\n        this.closed = false;\r\n        this.isStopped = false;\r\n        this._parent = _parent;\r\n        this._parents = _parents;\r\n        return this;\r\n    };\r\n    return Subscriber;\r\n}(Subscription));\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nvar SafeSubscriber = /*@__PURE__*/ (function (_super) {\r\n    __extends(SafeSubscriber, _super);\r\n    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {\r\n        _super.call(this);\r\n        this._parentSubscriber = _parentSubscriber;\r\n        var next;\r\n        var context = this;\r\n        if (isFunction(observerOrNext)) {\r\n            next = observerOrNext;\r\n        }\r\n        else if (observerOrNext) {\r\n            next = observerOrNext.next;\r\n            error = observerOrNext.error;\r\n            complete = observerOrNext.complete;\r\n            if (observerOrNext !== emptyObserver) {\r\n                context = Object.create(observerOrNext);\r\n                if (isFunction(context.unsubscribe)) {\r\n                    this.add(context.unsubscribe.bind(context));\r\n                }\r\n                context.unsubscribe = this.unsubscribe.bind(this);\r\n            }\r\n        }\r\n        this._context = context;\r\n        this._next = next;\r\n        this._error = error;\r\n        this._complete = complete;\r\n    }\r\n    SafeSubscriber.prototype.next = function (value) {\r\n        if (!this.isStopped && this._next) {\r\n            var _parentSubscriber = this._parentSubscriber;\r\n            if (!_parentSubscriber.syncErrorThrowable) {\r\n                this.__tryOrUnsub(this._next, value);\r\n            }\r\n            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\r\n                this.unsubscribe();\r\n            }\r\n        }\r\n    };\r\n    SafeSubscriber.prototype.error = function (err) {\r\n        if (!this.isStopped) {\r\n            var _parentSubscriber = this._parentSubscriber;\r\n            if (this._error) {\r\n                if (!_parentSubscriber.syncErrorThrowable) {\r\n                    this.__tryOrUnsub(this._error, err);\r\n                    this.unsubscribe();\r\n                }\r\n                else {\r\n                    this.__tryOrSetError(_parentSubscriber, this._error, err);\r\n                    this.unsubscribe();\r\n                }\r\n            }\r\n            else if (!_parentSubscriber.syncErrorThrowable) {\r\n                this.unsubscribe();\r\n                throw err;\r\n            }\r\n            else {\r\n                _parentSubscriber.syncErrorValue = err;\r\n                _parentSubscriber.syncErrorThrown = true;\r\n                this.unsubscribe();\r\n            }\r\n        }\r\n    };\r\n    SafeSubscriber.prototype.complete = function () {\r\n        var _this = this;\r\n        if (!this.isStopped) {\r\n            var _parentSubscriber = this._parentSubscriber;\r\n            if (this._complete) {\r\n                var wrappedComplete = function () { return _this._complete.call(_this._context); };\r\n                if (!_parentSubscriber.syncErrorThrowable) {\r\n                    this.__tryOrUnsub(wrappedComplete);\r\n                    this.unsubscribe();\r\n                }\r\n                else {\r\n                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);\r\n                    this.unsubscribe();\r\n                }\r\n            }\r\n            else {\r\n                this.unsubscribe();\r\n            }\r\n        }\r\n    };\r\n    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\r\n        try {\r\n            fn.call(this._context, value);\r\n        }\r\n        catch (err) {\r\n            this.unsubscribe();\r\n            throw err;\r\n        }\r\n    };\r\n    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\r\n        try {\r\n            fn.call(this._context, value);\r\n        }\r\n        catch (err) {\r\n            parent.syncErrorValue = err;\r\n            parent.syncErrorThrown = true;\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    SafeSubscriber.prototype._unsubscribe = function () {\r\n        var _parentSubscriber = this._parentSubscriber;\r\n        this._context = null;\r\n        this._parentSubscriber = null;\r\n        _parentSubscriber.unsubscribe();\r\n    };\r\n    return SafeSubscriber;\r\n}(Subscriber));\r\nfunction isTrustedSubscriber(obj) {\r\n    return obj instanceof Subscriber || ('syncErrorThrowable' in obj && obj[rxSubscriberSymbol]);\r\n}\r\n//# sourceMappingURL=Subscriber.js.map\r\n",null]}