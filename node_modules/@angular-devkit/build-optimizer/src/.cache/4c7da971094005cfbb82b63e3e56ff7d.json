{"remainingRequest":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\xampp\\htdocs\\GroupReads\\node_modules\\rxjs\\_esm5\\operator\\catch.js","dependencies":[{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\rxjs\\_esm5\\operator\\catch.js","mtime":1524743248102},{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1524743208736},{"path":"C:\\xampp\\htdocs\\GroupReads\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1524743165754}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START .._operators_catchError PURE_IMPORTS_END */\r\nimport { catchError as higherOrder } from '../operators/catchError';\r\n/**\r\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\r\n *\r\n * <img src=\"./img/catch.png\" width=\"100%\">\r\n *\r\n * @example <caption>Continues with a different Observable when there's an error</caption>\r\n *\r\n * Observable.of(1, 2, 3, 4, 5)\r\n *   .map(n => {\r\n * \t   if (n == 4) {\r\n * \t     throw 'four!';\r\n *     }\r\n *\t   return n;\r\n *   })\r\n *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))\r\n *   .subscribe(x => console.log(x));\r\n *   // 1, 2, 3, I, II, III, IV, V\r\n *\r\n * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>\r\n *\r\n * Observable.of(1, 2, 3, 4, 5)\r\n *   .map(n => {\r\n * \t   if (n === 4) {\r\n * \t     throw 'four!';\r\n *     }\r\n * \t   return n;\r\n *   })\r\n *   .catch((err, caught) => caught)\r\n *   .take(30)\r\n *   .subscribe(x => console.log(x));\r\n *   // 1, 2, 3, 1, 2, 3, ...\r\n *\r\n * @example <caption>Throws a new error when the source Observable throws an error</caption>\r\n *\r\n * Observable.of(1, 2, 3, 4, 5)\r\n *   .map(n => {\r\n *     if (n == 4) {\r\n *       throw 'four!';\r\n *     }\r\n *     return n;\r\n *   })\r\n *   .catch(err => {\r\n *     throw 'error in source. Details: ' + err;\r\n *   })\r\n *   .subscribe(\r\n *     x => console.log(x),\r\n *     err => console.log(err)\r\n *   );\r\n *   // 1, 2, 3, error in source. Details: four!\r\n *\r\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\r\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\r\n *  is returned by the `selector` will be used to continue the observable chain.\r\n * @return {Observable} An observable that originates from either the source or the observable returned by the\r\n *  catch `selector` function.\r\n * @method catch\r\n * @name catch\r\n * @owner Observable\r\n */\r\nexport function _catch(selector) {\r\n    return higherOrder(selector)(this);\r\n}\r\n//# sourceMappingURL=catch.js.map\r\n",null]}